% ============================================================================
%  MCKL/manual/tex/random.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2016, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Random number generating}
\label{chap:Random number generating}

The library has a comprehensive \rng system to facilitate implementation of
Monte Carlo algorithms. Similar to the standard library header \verb|<random>|,
there are mainly two parts of this system. The first is a set of \rng{} engines
that generate random integers. The other is a set of distribution generators.
The former are documented in Sections~\ref{sec:Counter-based RNG}
to~\ref{sec:MKL RNG}, and the later in Section~\ref{sec:Distribution}. Apart
from these, the library also provides facilities for vectorized random number
generating (Section~\ref{sec:Vectorized random number generating}) and using
multiple \rng{}s in parallel programs (Section~\ref{sec:Multiple RNG streams}).
There are also some performance data in Appendix~\appref{chap:Performance of
  random number generators} and~\appref{chap:Performance of distribution
  generators}.

\section{Vectorized random number generating}
\label{sec:Vectorized random number generating}

The generic function \verb|rand| provides vectorized random number generating.
There are two versions. The first operates on \rng engines and generates random
integers,
\begin{Verbatim}
  template <typename RNGType>
  inline void rand(
      RNGType &rng,
      size_t n,
      typename RNGType::result_type *r);
\end{Verbatim}
The effect of the function call,
\begin{Verbatim}
  rand(rng, n, r);
\end{Verbatim}
is equivalent to the loop,
\begin{Verbatim}
  for (size_t i = 0; i != n; ++i)
      r[i] = rng();
\end{Verbatim}
The results will always be the same unless a non-deterministic \rng is used.
For some \rng{}s implemented in the library, the vectorized version may have
considerable performance advantage.

The second version of \verb|rand| is for generating distribution random
numbers,
\begin{Verbatim}
  template <typename RNGType, typename DistributionType>
  inline void rand(
      RNGType &rng,
      const DistributionType &distribution,
      size_t n,
      typename DistributionType::result_type *r);
\end{Verbatim}
For example,
\begin{Verbatim}
  NormalDistribution<double> normal;
  rand(rng, normal, n, r);
\end{Verbatim}
This is similar to the following loop,
\begin{Verbatim}
  for (size_t i = 0; i != n; ++i)
      r[i] = normal(rng);
\end{Verbatim}
Depending on the type of \verb|rng| and the distribution (including its
parameters), the vectorized version may have superior performance. However, the
results will not be exactly the same as using a loop.

For consistency, the library also defines the function \verb|rand| for
generating only one random number,
\begin{Verbatim}
  rand(rng);               // rng();
  rand(rng, distribution); // distribution(rng);
\end{Verbatim}
And each \rng engine and distribution generator also has methods for vectorized
generating,
\begin{Verbatim}
  rng(n, r);               // rand(rng, n, r);
  distribution(rng, n, r); // rand(rng, distribution, n, r);
\end{Verbatim}
To write generic functions, it is recommended to use the function \verb|rand|
instead of the member methods, since the former also works with classes not
defined by this library, such as those in the standard library.

\section{Counter-based \texorpdfstring{\protect\rng}{RNG}}
\label{sec:Counter-based RNG}

The standard library provides a set of \rng engines. Unfortunately, none of
them are suitable for parallel computing without considerable efforts. To
illustrate the problem, consider the situation where there are two threads that
need to generate random numbers. And thus two \rng engine instances need to be
created for each thread. Let the random numbers generated by them be
$\{r_i^1\}_{i>0}$ and $\{r_i^2\}_{i>0}$. Because of the deterministic and
recursive natural of the these \rng{}s, there exists $k\in\Integer$, such that,
$r_i^1 = r_{i + k}^2$ for all $i > \max\{0, -k\}$. If $\Abs{k}$ is larger than
or close to the total number of random numbers required in each thread, then
this situation might not be an issue. However, there is no easy way to ensure
such a condition.

There are two standard solutions to this problem. The first is to use
sub-streams for each thread. For example,
\begin{Verbatim}
  std::mt19937 rng;

  // Thread k
  std::mt19937 rng_k = rng;
  rng_k.discard(n * k);
\end{Verbatim}
where $n$ is the number of random numbers required by each thread. The $k$\ith
thread only uses the random numbers in the sub-stream $\{r_i\}_{nk < i \le
  n(k+1)}$. For this to work, the \rng needs a fast \verb|discard|
implementation, preferably with $O(1)$ cost. In addition, one needs to manage
\rng{}s explicitly for each thread, which prevents this method to be used in
environments where threads are created implicitly, such as using \tbb for
parallelization.

The second solution is to use a leap-frog algorithm, such that each thread will
use the elements $\{r_{iK + k}\}_{i>0}$ of the stream, where $K$ is the total
number of threads. This is not directly supported in the standard library, but
can be emulated,
\begin{Verbatim}
  std::mt19937 rng;

  // Thread k
  std::mt19937 tmp = rng;
  tmp.discard(k);
  std::discard_block_engine<std::mt19937, K, 1> rng_k(tmp);
\end{Verbatim}
This not only requires managing the \rng{}s explicitly, but also knowing the
number of threads at compile-time, which prevents it to be used in any
applications using dynamic parallelization. And similar to the first solution,
it cannot be used when threads are created implicitly.

The development by \cite{Salmon:2011um} made high performance parallel \rng
much more accessible. The \rng{}s introduced in the paper use bijection $f_k$,
such that, for a sequence $\{c_i = i\}_{i\ge0}$, the sequence $\{y_i =
f_k(c_i)\}_{i\ge0}$ appears random. In addition, for $k_1 \ne k_2$, $f_{k_1}$
and $f_{k_2}$ will generate two sequences that appear statistically
independent. Compared to more conventional \rng{}s which use recursions $y_i =
f_k(y_{i - 1})$, these counter-based \rng{}s are much easier to setup in a
parallelized environment. If $c$, the counter, is an unsigned integer with $b$
bits, and $k$, the key, is an unsigned integer with $d$ bits. Then for each
$k$, the \rng has a period $2^b$. And there can be at most $2^d$ independent
streams. Another way is to view this kind of \rng{}s is that, it is one \rng{}
with state $\{c, k\}$ for $0 \le c < 2^b$ and $0 \le k < 2^d$. And thus it has
a period $2^{b + d}$. And the division of the state into counter and key
provides an easy way to setup a large number of sub-streams.

Of course, not any sequence of counters and keys are suitable. The \rng{}s are
still deterministic. Since $f_k$ for any given $k$ is a bijection, the sequence
of counter $\{c_i = f_k^{-1}(i)\}_{i\ge0}$ will of course produce a very
regular sequence $\{y_i = i\}_{i\ge0}$. However, for regular sequences, such as
$\{c_i = i\}_{i\ge0}$ and $\{k_j = j\}_{j\ge0}$, the resulting sequences
$\{\{y_i\}_{i\ge0}^j\}_{j\ge0}$ appear random. See \cite{Salmon:2011um} for
more details.

Table~\ref{tab:Counter-based RNG} lists all counter-based \rng{}s implemented
in the library, along with the bits of the counter and the key. They all output
32-bit unsigned integers uniform on the set $\{0,\dots,2^{32}-1\}$. For 64-bit
output, a suffix \verb|_64| may be appended to the corresponding \rng engine
names. For example, \verb|Threefry4x64| and \verb|Threefry4x64_64| both
generate the same 256-bit random integers internally. The only difference is
that \verb|operator()| of the former returns 32 of those 256 bits each time it
is executed, while the later returns 64 bits.

All \rng{}s in Table~\ref{tab:Counter-based RNG} are actually type aliases.
More generally the library defines the following class template as the
interface,
\begin{Verbatim}
  template <typename ResultType, typename Generator>
  class CounterEngine;
\end{Verbatim}
where \verb|ResultType| shall be an unsigned integer type and \verb|Generator|
is the class that actually implements the algorithm. See the reference manual
for details of the generator type. For most users, those implemented in the
library are sufficient. They are introduced in the next few sections. A few
configuration macros of these generators are listed in
Table~\ref{tab:Configuration macros for counter-based RNG} and will be referred
to later.

\begin{table}
  \tbfigures
  \begin{tabularx}{\textwidth}{p{2.6in}LL}
    \toprule
    \rng engine & Counter bits & Key bits \\
    \midrule
    \verb|AES128x1|, \verb|ARS128x2|, \verb|AES128x4|, \verb|AES128x8|
    & 128 & 128 \\
    \verb|AES192x1|, \verb|ARS192x2|, \verb|AES192x4|, \verb|AES192x8|
    & 128 & 192 \\
    \verb|AES256x1|, \verb|AES256x2|, \verb|AES256x4|, \verb|AES256x8|
    & 128 & 256 \\
    \verb|ARSx1|, \verb|ARSx2|, \verb|ARSx4|, \verb|ARSx8| & 128 & 128 \\
    \verb|Philox2x32|    & 64   & 32   \\
    \verb|Philox2x64|    & 128  & 64   \\
    \verb|Philox4x32|    & 128  & 64   \\
    \verb|Philox4x64|    & 256  & 128  \\
    \verb|Threefry2x32|  & 64   & 64   \\
    \verb|Threefry2x64|  & 128  & 128  \\
    \verb|Threefry4x32|  & 128  & 128  \\
    \verb|Threefry4x64|  & 256  & 256  \\
    \verb|Threefry8x64|  & 512  & 512  \\
    \verb|Threefry16x64| & 1024 & 1024 \\
    \bottomrule
  \end{tabularx}
  \caption{Counter-based \protect\rng}
  \label{tab:Counter-based RNG}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LL}
    \toprule
    Macro & Default \\
    \midrule
    \verb|MCKL_AES128_ROUNDS|          & \verb|10| \\
    \verb|MCKL_AES192_ROUNDS|          & \verb|12| \\
    \verb|MCKL_AES256_ROUNDS|          & \verb|14| \\
    \verb|MCKL_ARS_ROUNDS|             & \verb|5|  \\
    \verb|MCKL_AESNI_BLOCKS|           & \verb|8|  \\
    \verb|MCKL_PHILOX_ROUNDS|          & \verb|10| \\
    \verb|MCKL_PHILOX_VECTOR_LENGTH|   & \verb|4|  \\
    \verb|MCKL_THREEFRY_ROUNDS|        & \verb|20| \\
    \verb|MCKL_THREEFRY_VECTOR_LENGTH| & \verb|4|  \\
    \bottomrule
  \end{tabularx}
  \caption{Configuration macros for counter-based \protect\rng}
  \label{tab:Configuration macros for counter-based RNG}
\end{table}

\subsection{\texorpdfstring{\protect\aesni}{AES-NI} instructions based
  \texorpdfstring{\protect\rng}{RNG}}
\label{sub:AES-NI instructions based RNG}

The \aesni\footnote{\url{https://en.wikipedia.org/wiki/AES_instruction_set}}
instructions based \rng{}s in \cite{Salmon:2011um} are implemented in the
following generator,
\begin{Verbatim}
  template <typename KeySeqType, size_t Rounds, size_t Blocks>
  class AESNIGenerator;
\end{Verbatim}
The corresponding \rng engine is,
\begin{Verbatim}
  template <
      typename ResultType,
      typename KeySeqType,
      size_t Rounds,
      size_t Blocks>
  using AESNIEngine = CounterEngine<
          ResultType,
          AESNIGenerator<KeySeqType, Rounds, Blocks>>;
\end{Verbatim}
where \verb|KeySeqType| is the class used to generate the sequences of round
keys. The parameter \verb|Rounds| is the number of rounds of \aes encryption to
be performed. See the reference manual for details of how to define the key
sequence class. The \aesni encryption instructions have a latency of seven or
eight cycles, while they can be issued at every cycle. Therefore better
performance can be achieved if multiple 128-bit random integers are generated
at the same time. This is specified by the template parameter \verb|Blocks|.
Larger blocks, up to eight, might improve performance. But this is at the cost
of larger state size. Without going into details, there are four types of
sequence of round keys implemented by the library,
\begin{Verbatim}
  template <size_t Rounds>
  using AES128KeySeq = internal::AESKeySeq<
      Rounds, internal::AES128KeySeqGenerator>;

  template <size_t Rounds>
  using AES192KeySeq = internal::AESKeySeq<
      Rounds, internal::AES192KeySeqGenerator>;

  template <size_t Rounds>
  using AES256KeySeq = internal::AESKeySeq<
      Rounds, internal::AES256KeySeqGenerator>;

  template <typename Constants = ARSConstants>
  using ARSKeySeq = internal::ARSKeySeqImpl<Constants>;
\end{Verbatim}
and correspondingly four \rng engines,
\begin{Verbatim}
  template <
      typename ResultType,
      size_t Rounds = MCKL_AES128_ROUNDS,
      size_t Blocks = MCKL_AESNI_BLOCKS>
  using AES128Engine = AESNIEngine<
      ResultType, AES128KeySeq<Rounds>, Rounds, Blocks>;

  template <
      typename ResultType,
      size_t Rounds = MCKL_AES192_ROUNDS,
      size_t Blocks = MCKL_AESNI_BLOCKS>
  using AES192Engine = AESNIEngine<
      ResultType, AES192KeySeq<Rounds>, Rounds, Blocks>;

  template <
      typename ResultType,
      size_t Rounds = MCKL_AES256_ROUNDS,
      size_t Blocks = MCKL_AESNI_BLOCKS>
  using AES256Engine = AESNIEngine<
      ResultType, AES256KeySeq<Rounds>, Rounds, Blocks>;

  template <
      typename ResultType,
      size_t Rounds = MCKL_ARS_ROUNDS,
      size_t Blocks = MCKL_AESNI_BLOCKS,
      typename Constants = ARSConstants>
  using ARSEngine = AESNIEngine<
      ResultType, ARSKeySeq<Constants>, Rounds, Blocks>;
\end{Verbatim}
The first three are equivalent to \aes-128, \aes-192 and \aes-256 block ciphers
used in counter mode. The last is the \ars algorithm introduced by
\cite{Salmon:2011um}. The last template parameter \verb|Constants| of
\verb|ARSKeySeq| and \verb|ARSEngine| is a trait class that defines the
constants of the Weyl's sequence. See \textcite{Salmon:2011um} for details. The
defaults are taken from the paper. To use an alternative pair of 64-bit
integers as the constants, one can define and use a trait class as the
following,
\begin{Verbatim}
  template <size_t>
  struct NewWeylConstant;

  template<>
  struct NewWeylConstant<0>
  {
      static constexpr std::uint64_t value = FIRST_CONSTANT;
  };

  template<>
  struct NewWeylConstant<1>
  {
      static constexpr std::uint64_t value = SECOND_CONSTANT;
  };

  struct NewConstants
  {
      template <size_t I>
      using weyl = NewWeylConstant<I>;
  };

  using NewARS = ARSEngine<ResultType, Rounds, NewConstants>;
\end{Verbatim}
Alternative methods are also possible. The only requirement is that, the
following statement,
\begin{Verbatim}
  template <size_t I>
  using weyl = typename Constants::template weyl<I>;
\end{Verbatim}
shall define the type \verb|weyl| such that it has a static constant expression
member data \verb|value| that is the \verb|I|\ith Weyl constant. A few type
aliases are defined for convenience. For example,
\begin{Verbatim}
  using ARSx8    = ARSEngine<std::uint32_t, MCKL_ARS_ROUNDS, 8>;
  using ARSx8_64 = ARSEngine<std::uint64_t, MCKL_ARS_ROUNDS, 8>;
  using ARS      = ARSEngine<std::uint32_t>;
  using ARS_64   = ARSEngine<std::uint64_t>;
\end{Verbatim}
The engine \verb|ARS| is the library's default \rng if \aesni instructions are
supported. Aliases for block sizes 1, 2, 4 and 8 are defined for all four
algorithms, as well as both 32- and 64-bit output versions. These aliases are
listed in Table~\ref{tab:Counter-based RNG}. The performance of these engines
depends on a few factors, such as \cpu types, compilers, operating systems,
etc. In any case, the performance is good enough even for the most demanding
applications. The library does not attempt to optimize the algorithm for any
particular platform. In realistic applications, the performance of \rng is
unlikely to become a bottle neck. Note that, the best performance is obtained
with the vectorized \verb|rand| function (see Section~\ref{sec:Vectorized
  random number generating}).

\subsection{Philox}
\label{sub:Philox}

The Philox algorithm in \cite{Salmon:2011um} is implemented in the following
generator,
\begin{Verbatim}
  template <
      typename T,
      size_t K = MCKL_PHILOX_VECTOR_LENGTH,
      size_t Rounds = MCKL_PHILOX_ROUNDS,
      typename Constants = PhiloxConstants<T, K>>
  class PhiloxGenerator;
\end{Verbatim}
The corresponding \rng engine is,
\begin{Verbatim}
  template <
      typename ResultType,
      typename T = ResultType,
      size_t K = MCKL_PHILOX_VECTOR_LENGTH,
      size_t Rounds = MCKL_PHILOX_ROUNDS,
      typename Constants = PhiloxConstants<T, K>>
  using PhiloxEngine = CounterEngine<
      ResultType, PhiloxGenerator<T, K, Rounds, Constants>>;
\end{Verbatim}
The default vector length and the number of rounds can be changed by
configuration macros listed in Table~\ref{tab:Configuration macros for
  counter-based RNG}. There is no limit on the template parameter \verb|K| or
\verb|Rounds|, nor any limitation on \verb|T| except that it has to be an
unsigned integer type. See \cite{Salmon:2011um} on the most general form of the
algorithm. However, the library only provides default constants for 32- and
64-bit unsigned integer type \verb|T| and \verb|K| taking the values \verb|2|
or \verb|4|. These four engines are defined as type aliases for convenience,
\begin{Verbatim}
  template <typename ResultType>
  using Philox2x32Engine = PhiloxEngine<
      ResultType, std::uint32_t, 2>;

  template <typename ResultType>
  using Philox4x32Engine = PhiloxEngine<
      ResultType, std::uint32_t, 4>;

  template <typename ResultType>
  using Philox2x64Engine = PhiloxEngine<
      ResultType, std::uint64_t, 2>;

  template <typename ResultType>
  using Philox4x64Engine = PhiloxEngine<
      ResultType, std::uint64_t, 4>;
\end{Verbatim}
Type aliases for 32- and 64-bit \verb|ResultType| are also defined, as listed
in Table~\ref{tab:Counter-based RNG}. To use the engine with \verb|K| taking
values larger than four, or \verb|T| being unsigned integer type with number of
bits other than 32 or 64, one needs to provide a suitable trait class,
\verb|Constant|. It is similar to that of \verb|ARSEngine|. See the reference
manual of \verb|PhiloxConstants| for an example of how to define it.

\subsection{Threefry}
\label{sub:Threefry}

The Threefry algorithm in \cite{Salmon:2011um} is implemented in the following
generator,
\begin{Verbatim}
  template <
      typename T,
      size_t K = MCKL_THREEFRY_VECTOR_LENGTH,
      size_t Rounds = MCKL_THREEFRY_ROUNDS,
      typename Constants = ThreefryConstants<T, K>>
  class ThreefryGenerator;
\end{Verbatim}
The corresponding \rng engine is,
\begin{Verbatim}
  template <
      typename ResultType,
      typename T = ResultType,
      size_t K = MCKL_THREEFRY_VECTOR_LENGTH,
      size_t Rounds = MCKL_THREEFRY_ROUNDS,
      typename Constants = ThreefryConstants<T, K>>
  using ThreefryEngine = CounterEngine<
      ResultType, ThreefryGenerator<T, K, Rounds, Constants>>;
\end{Verbatim}
The default vector length and the number of rounds can be changed by
configuration macros listed in Table~\ref{tab:Configuration macros for
  counter-based RNG}. Similar to the implementation of the Philox algorithm,
there is no limit on the template parameter \verb|K| or \verb|Rounds| as long
as a suitable trait class \verb|Constant| is provided. The library provides
default constants for 64-bit unsigned integer type \verb|T| and \verb|K| taking
the values \verb|4|, \verb|8| and \verb|16|, taken from the
skein\footnote{\url{http://www.skein-hash.info}} hash algorithm, for which the
Threefish algorithm was originally developed for. Defaults for 32-bit \verb|T|
or \verb|K| taking the value \verb|2| are also provided, taken from
\cite{Salmon:2011um}. Type aliases for these configurations are defined for
convenience,
\begin{Verbatim}
  template <typename ResultType>
  using Threefry2x32Engine = ThreefryEngine<
      ResultType, std::uint32_t, 2>;

  template <typename ResultType>
  using Threefry4x32Engine = ThreefryEngine<
      ResultType, std::uint32_t, 4>;

  template <typename ResultType>
  using Threefry2x64Engine = ThreefryEngine<
      ResultType, std::uint64_t, 2>;

  template <typename ResultType>
  using Threefry4x64Engine = ThreefryEngine<
      ResultType, std::uint64_t, 4>;

  template <typename ResultType>
  using Threefry8x64Engine = ThreefryEngine<
      ResultType, std::uint64_t, 8>;

  template <typename ResultType>
  using Threefry16x64Engine = ThreefryEngine<
      ResultType, std::uint64_t, 16>;
\end{Verbatim}
Type aliases for 32- and 64-bit \verb|ResultType| are also defined, as listed
in Table~\ref{tab:Counter-based RNG}.

\subsection{\texttt{RNG} and \texttt{RNGMini}}
\label{sub:RNG and RNGMini}

Note that, not all \rng{}s implemented by the library is available on all
platforms. The library also defines two type aliases \verb|RNG| and
\verb|RNG_64|, which are one of the \rng{}s listed in
Table~\ref{tab:Counter-based RNG}. The preference is in the order listed in
Table~\ref{tab:Type aliases RNG and RNG_64}. The user can define the
configuration macro \verb|MCKL_RNG_TYPE| to override the choice of \verb|RNG|
made by the library. Similarly, the \verb|MCKL_RNG_64_TYPE| macro can be used
to override the choice of \verb|RNG_64|. These \rng engines are meant for
general purpose usage. They have reasonable long period and large key space.

\begin{table}
  \begin{tabularx}{\textwidth}{LLL}
    \toprule
    Alias  & \rng engine & Availability \\
    \midrule
    \verb|RNG|    & \verb|ARS|         & \verb|MCKL_HAS_AESNI| \\
                  & \verb|Threefry|    & Always available      \\
    \verb|RNG_64| & \verb|ARS_64|      & \verb|MCKL_HAS_AESNI| \\
                  & \verb|Threefry_64| & Always available      \\
    \bottomrule
  \end{tabularx}
  \caption{Type aliases \protect\texttt{RNG} and \protect\texttt{RNG\_64}}
  \label{tab:Type aliases RNG and RGN_64}
\end{table}

The library also defines two type aliases \verb|RNGMini| and \verb|RNGMini_64|,
which have the smallest state size among all \rng engines defined by the
library. By default they are \verb|Philox2x32| and \verb|Philox2x32_64|. The
choice can be overridden by configuration macros \verb|MCKL_RNG_MINI_TYPE| and
\verb|MCKL_RNG_MINI_64_TYPE|, respectively.

\subsection{Seeding counter-based \texorpdfstring{\protect\rng}{RNG}}
\label{sub:Seeding counter-based RNG}

The singleton class template \verb|SeedGenerator| can be used to generate
distinctive seeds sequentially. For example,
\begin{Verbatim}
  auto &seed = SeedGenerator<void, unsigned>::instance();
  RNG rng1(seed.get()); // Construct rng1
  RNG rng2(seed.get()); // Construct rng2 with another seed
\end{Verbatim}
The first argument to the template can be any type. For different types,
different instances of \verb|SeedGenerator| will be created. Thus, the seeds
generated by two generators, \verb|SeedGenerator<T1>| and
\verb|SeedGenerator<T2>|, will be independent. The second parameter is the type
of the seed values. It can be any unsigned integer type. Classes such as
\verb|Particle<T>| will use the generator of the following type,
\begin{Verbatim}
  using Seed = SeedGenerator<NullType, MCKL_SEED_RESULT_TYPE>;
\end{Verbatim}
where \verb|MCKL_SEED_RESULT_TYPE| is a configuration macro which is defined to
\verb|unsigned| by default.

One can save and set the seed generator using standard streams. For example,
\begin{Verbatim}
  std::ifstream is("seed.txt");
  if (is)
      is >> Seed::instance();    // Read seed from a file
  else
      Seed::instance().set(101); // Set it manually
  is.close();
  // Using Seed
  std::ofstream os("seed.txt");
  os << Seed::instance();        // Write the seed to a file
  os.close();
\end{Verbatim}
This way, if the simulation program needs to be repeated multiple times, each
time it will use a different set of seeds. A single seed generator is enough
for a single program. However, it is more difficult to ensure that each
computing node has a distinctive set of seeds in a distributed system. A simple
solution is to use the \verb|modulo| method of \verb|SeedGenerator|. For
example,
\begin{Verbatim}
  Seed::instance().modulo(n, r);
\end{Verbatim}
where $n$ is the number of processes and $r$ is the rank of the current node.
After this call, all seeds generated will belong to the equivalent class $s
\equiv r \mod n$. Therefore, no two nodes will ever generate the same seeds.
Note that, the seeds generated are not random at all. For any deterministic
\rng{}s, the same seeds always produce identical streams. However, distinctive
seeds does not always lead to independent streams. This seed generator is only
suitable for counter-based \rng{}s.

\section{Non-deterministic \texorpdfstring{\protect\rng}{RNG}}
\label{sec:Non-deterministic RNG}

If the \rdrand instructions are supported, the library also implements three
\rng{}s, \verb|RDRAND16|, \verb|RDRAND32| and \verb|RDRAND64|. They output 16-,
32-, and 64-bit random integers, respectively. The \rdrand instruction may not
return a random integer at all. The \rng engine will keep trying until it
succeeds. One can limit the maximum number of trials by defining the
configuration macro \verb|MCKL_RDRAND_NTRIAL_MAX|. A value of zero, the
default, means the number of trials is unlimited. If it is a positive number,
and if after the specified number of trials no random integer is return by the
\rdrand instruction, zero is returned.

\section{\texorpdfstring{\protect\rng{} \protect\rng}{MKL RNG}}
\label{sec:MKL RNG}

The \mkl library provides some high performance \rng{}s. The library implements
a wrapper class \verb|MKLEngine| that makes them accessible as \cpp engines.
They are listed in Table~\ref{tab:MKL RNG}. Note that, \mkl{} \rng{}s perform
the best when they are used to generate vectors of random numbers. These
wrappers use a buffer to store such vectors. And thus they have much larger
state space than usual \rng{}s. Each \rng engines output by default 32-bit
integers. Similar to the counter-based \rng{}s, 64-bit variants are also
defined.

When there are \mkl routines for generating distribution random variates for
one of the distributions discussed later in Section~\ref{sec:Distribution}, the
library will automatically use \mkl routines for vectorized random number
generating if the \rng{} is one of that listed in Table~\ref{tab:MKL RNG}. For
example,
\begin{Verbatim}
  MKL_SFMT19937 rng;
  NormalDistribution<double> normal;
  normal(rng, n, r);       // Use MKL
  rand(rng, normal, n, r); // Use MKL
\end{Verbatim}
Note that, this is only applicable when the distribution is a class in this
library. It will not work with classes such as \verb|std::normal_distribution|.
This is also applicable when the distribution is not directly supported by
\mkl, but can be easily generated using other distributions, e.g., the
Student's $t$-distribution. In addition, it is also applicable if a
distribution is a special case of one of the distributions supported by \mkl.

\begin{table}
  \begin{tabularx}{\textwidth}{LL}
    \toprule
    \rng engine & \mkl{} \brng \\
    \midrule
    \verb|MKL_MCG59|         & \verb|VSL_BRNG_MCG59|         \\
    \verb|MKL_MT19937|       & \verb|VSL_BRNG_MT19937|       \\
    \verb|MKL_MT2203|        & \verb|VSL_BRNG_MT2203|        \\
    \verb|MKL_SFMT19937|     & \verb|VSL_BRNG_SFMT19937|     \\
    \verb|MKL_NONDETERM|     & \verb|VSL_BRNG_NONDETERM|     \\
    \verb|MKL_ARS5|          & \verb|VSL_BRNG_ARS5|          \\
    \verb|MKL_PHILOX4X32X10| & \verb|VSL_BRNG_PHILOX4X32X10| \\
    \bottomrule
  \end{tabularx}
  \caption{\protect\mkl{} \protect\rng}
  \label{tab:MKL RNG}
\end{table}

\section{Multiple \texorpdfstring{\protect\rng}{RNG} streams}
\label{sec:Multiple RNG streams}

Earlier in Section~\ref{sec:Particle} we introduced that \verb|particle.rng(i)|
returns an independent \rng instance. This is actually done through a class
template called \verb|RNGSet|. Three of them are implemented in the library.
They all have the same interface,
\begin{Verbatim}
  RNGSet<RNG> rng_set(N); // A set of N RNGs
  rng_set.resize(n);      // Change the size of the set
  rng_set[i];             // Get a reference to the i-th RNG
  rng_set.seed();         // Seed each RNG in the set
                          // with Seed::instance()
\end{Verbatim}
The first implementation is \verb|RNGSetScalar|. As its name suggests, it is
only a wrapper of a single \rng. All calls to \verb|rng_set[i]| returns a
reference to the same \rng. It is only useful when an \verb|RNGSet| interface
is required while the thread-safety and other issues are not important.

The second implementation is \verb|RNGSetVector|. It is an array of \rng{}s
with length $N$. It has memory cost $O(N)$. Many of the counter-based \rng{}s
have small state size and thus for moderate $N$, this cost is not an issue. The
method calls \verb|rng_set[i]| and \verb|rng_set[j]| return independent \rng{}s
if $i \ne j$. This implementation has the advantage that the behavior of an
algorithm can be entirely deterministic even when the scheduling of parallel
execution is dynamic, since each sample has its own \rng.

Last, if \tbb is available, there is a third implementation \verb|RNGSetTBB|,
which uses thread-local storage (\tls). It has much smaller memory footprint
than \verb|RNGSetVector| while maintains better thread-safety. The performance
impact of using \tls is minimal unless the computation at the calling site is
trivial. For example,
\begin{Verbatim}
  void eval_each(size_t, ParticleIndex<T> idx)
  {
      auto &rng = idx.rng();
      // using rng to initialize state
      // do some computation, likely far more costly than TLS
  }
\end{Verbatim}
The type alias \verb|RNGSet| is defined to be \verb|RNGSetTBB| if \tbb is
available, otherwise defined to be \verb|RNGSetVector|. It is used by the
\verb|Particle| class template. One can replace the type of \rng set used by
\verb|Particle<T>| with a member type of \verb|T|. For example,
\begin{Verbatim}
  class T
  {
      public:
      using rng_set_type = RNGSetScalar<RNG>;
  };
\end{Verbatim}
will replace the type of the \rng set contained in \verb|Particle<T>|. One can
also define their own replacement type, as long as it has the same interface as
the builtin ones.

\section{Distribution}
\label{sec:Distribution}

The library provides implementations of some common distributions. Some of them
are the same as those in the standard library with \verb|CamelCase| names. For
example, \verb|NormalDistribuiton| can be used as a drop-in replacement of
\verb|std::normal_distribuiton|. This includes all of the continuous
distributions in the standard library. As stated in Section~\ref{sec:Vectorized
  random number generating}, all the distributions defined in the library
support vectorized random number generating. In the following sections, we
introduce each of them. Section~\ref{sub:Uniform bits distribution} discusses
the uniform bits distribution, which is actually a low level distribution
indirectly used by all other distributions. Section~\ref{sub:Standard uniform
  distribution} shows few different standard uniform distributions. And in
Sections~\ref{sub:Continuous distributions} and~\ref{sub:Discrete
  distributions} we list continuous and discrete distributions, respectively.
In these two sections, the \pdf or \pmf and class declaration of each
distribution are shown first, and then we briefly discuss the algorithm used
for implementation. Last, in Section~\ref{sub:Multivariate distributions} we
briefly discusses a few multivariate distributions implemented in the library.

\subsection{Uniform bits distribution}
\label{sub:Uniform bits distribution}

The class template,
\begin{Verbatim}
  template <typename UIntType>
  class UniformBitsDistribution;
\end{Verbatim}
is similar to the standard library's \verb|std::independent_bits_engine|,
except that it always generates full size random integers and \verb|UIntType|
must have size at least of that of \verb|short|. That is, let $W$ be the number
of bits of \verb|UIntType|, then the output is uniform on the set
$\{0,\dots,2^W - 1\}$. For example,
\begin{Verbatim}
  UniformBitsDistribution<std::uint32_t> ubits;
  ubits(rng); // Return 32-bit random integers
\end{Verbatim}
Let $\rmin$ and $\rmax$ be the minimum and maximum of the random integers
generated by \verb|rng|. Let $R = \rmax - \rmin + 1$. Let $r_i$ be consecutive
output of \verb|rng()|. If there exists an integer $V > 0$ such that $R = 2^V$,
then the result is,
\begin{equation*}
  U = \sum_{k = 0}^{K - 1} (r_k - \rmin) 2^{kV} \bmod 2^W
\end{equation*}
where $K = \Ceil{W / V}$. Unlike \verb|std::independent_bits_engine|, the
calculation can be vectorized, which leads to better performance. Note that,
all constants in the algorithm are computed at compile-time and the summation
is fully unrolled. There is no runtime overhead. In the case $\rmin = 0$ and $V
= W$, most optimizing compilers shall be able to generate instructions such
that the distribution does exactly nothing and returns the results of
\verb|rng()| directly. If there does not exist an integer $V > 0$ such that $R
= 2^V$, then \verb|std::indepdent_bits_engine| will be used.

\subsection{Standard uniform distribution}
\label{sub:Standard uniform distribution}

The library provides five standard uniform distributions. They are all class
templates with a single template type parameter \verb|RealType|. The random
integers produced by \rng{}s are transferred to 32- or 64-bit random integers
through the class \verb|UniformBitsDistribution| before they are mapped to
floating point numbers within the interval $[0, 1]$. The integer type depends
on \verb|RealType|, the range of the \rng{}, $R$, and
\verb|MCKL_U01_USE_64BITS_DOUBLE|, a configuration macro. The exact relations
are listed in Table~\ref{tab:Intermediate integer types of uniform
  distributions}. In the following, let $W$ be the number of bits of the
integer type, and $M$ be the number of significant bits (including the implicit
one) of \verb|RealType|. We also denote the input random integers as $U$ and
the output random real numbers as $X$.

\begin{table}
  \begin{tabularx}{\textwidth}{LlL}
    \toprule
    \verb|RealType| & Conditions & Integer type \\
    \midrule
    \verb|float|  & $\log_2 R \ge 64$   & \verb|std::uint64_t| \\
                  & Otherwise           & \verb|std::uint32_t| \\
    \verb|double| & $\log_2 R \ge 64$   & \verb|std::uint64_t| \\
    & \verb|MCKL_U01_USE_64BITS_DOUBLE| & \verb|std::uint64_t| \\
    & Otherwise                         & \verb|std::uint32_t| \\
    \verb|long double| & Always         & \verb|std::uint64_t| \\
    \bottomrule
  \end{tabularx}
  \caption{Intermediate integer types of uniform distributions}
  \label{tab:Intermediate integer types of uniform distributions}
\end{table}

\subsubsection{\texttt{U01Distribution}}

The class template,
\begin{Verbatim}
  template <typename RealType = double>
  class U01Distribution;
\end{Verbatim}
implements the uniform distribution on $[0, 1)$. If
\verb|MCKL_U01_USE_FIXED_POINT| is true, which is the default, then it is an
alias to \verb|U01CODistribution| (see below). Otherwise, it is implemented
through the mapping,
\begin{align*}
  P &= \Floor{(W + M - 1) / W} \\
  K &= \max\{1, P\} \\
  X &= \sum_{k=0}^{K - 1} U_k 2^{-(K - k)W}
\end{align*}

\subsubsection{\texttt{U01CCDistribution}}

The class template,
\begin{Verbatim}
  template <typename RealType = double>
  class U01CCDistribution;
\end{Verbatim}
implements the uniform distribuiton on $[0, 1]$ through the mapping,
\begin{align*}
  P &= \min\{W - 1, M\} \\
  V &= \begin{cases}
    U &\text{if } P + 1 < W \\
    \Floor{(U \bmod 2^{W - 1}) / 2^{W - P -2}} &\text{otherwise}
  \end{cases} \\
  Z &= (V \bmod 2) + V \\
  X &= 2^{-(P + 1)} Z
\end{align*}
The minimum and maximum are $0$ and $1$, respectively.

\subsubsection{\texttt{U01CODistribution}}

The class template,
\begin{Verbatim}
  template <typename RealType = double>
  class U01CODistribution;
\end{Verbatim}
implements the uniform distribuiton on $[0, 1)$ through the mapping,
\begin{align*}
  P &= \min\{W, M\} \\
  V &= \Floor{U / 2^{W - P}} \\
  X &= 2^{-P} V
\end{align*}
The minimum and maximum are $0$ and $1 - 2^{-P}$, respectively.

\subsubsection{\texttt{U01OCDistribution}}

The class template,
\begin{Verbatim}
  template <typename RealType = double>
  class U01OCDistribution;
\end{Verbatim}
implements the uniform distribuiton on $(0, 1]$ through the mapping,
\begin{align*}
  P &= \min\{W, M\} \\
  V &= \Floor{U / 2^{W - P}} \\
  X &= 2^{-P} V + 2^{-P}
\end{align*}
The minimum and maximum are $2^{-P}$ and $1$, respectively.

\subsubsection{\texttt{U01OODistribution}}

The class template,
\begin{Verbatim}
  template <typename RealType = double>
  class U01CODistribution;
\end{Verbatim}
implements the uniform distribuiton on $(0, 1)$ through the mapping,
\begin{align*}
  P &= \min\{W + 1, M\} \\
  V &= \Floor{U / 2^{W + 1 - P}} \\
  X &= 2^{-(P - 1)} V + 2^{-P}
\end{align*}
The minimum and maximum are $2^{-P}$ and $1 - 2^{-P}$, respectively.

\subsubsection{Performance and accuracy considerations}

The last four distributions actually produce ``fixed point'' numbers. The
output $X$ can be represented exactly by the target \verb|RealType|. They have
two advantages. First, when it is important that the lower or upper bound is
never produced, to avoid underflow, overflow or other undefined behaviors in
subsequent calculations, they provide such assurance. The implementation of the
other distributions discussed later rely on these behaviors to avoid producing
infinite numbers. Second, they usually can be executed with only a couple of
instructions by modern processors. And thus can have better performance.

The main drawback is accuracy. If \verb|RealType| is \verb|float| or
\verb|long double|, then the difference is minimal, since the random integers
have more bits than the significant of the target floating point types. The
situation is a bit more tricky when the output type is \verb|double| and the
integer type has only 32 bits. In this case, \verb|U01CODistribution|, etc.,
can only produce $2^{32}$ distinctive values while \verb|double| can represent
much more values exactly within the range $[0, 1]$. In contrast, the standard
library will use at least 53 random bits. This will not matter in many
realistic applications. In fact, random numbers produced by
\verb|U01CODistribution|, etc., passes all tests in the {\lnfigures\tbfigures
  TestU01}%
\footnote{\url{http://www.iro.umontreal.ca/~simardr/testu01/tu01.html}} library
that \verb|std::uniform_real_distribution| would pass, for a good \rng. In
other words, the quality of the \rng is the dominating factor.

However, there are situations where one does want the extra precision. In this
case, one can define \verb|MCKL_U01_USE_64BITS_DOUBLE| to a non-zero value,
such that the random integers will always be 64-bit for \verb|double| output.

\subsection{Continuous distributions}
\label{sub:Continuous distributions}

All continuous distributions support all three types of floating point numbers,
unless stated otherwise.

\subsubsection{Arcsine distribution}

\begin{equation*}
  f(x;\alpha,\beta) = \frac{1}{\pi\sqrt{(x - \alpha)(\beta - x)}} \qquad
  x \in [a, b],\; a \in (0,\infty),\; b \in (0,\infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class ArcsineDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Beta distribution}

\begin{equation*}
  f(x;\alpha,\beta) =
  \frac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)}
  x^{\alpha - 1}(1 - x)^{\beta - 1} \qquad
  x \in (0, 1),\; \alpha \in (0,\infty),\; \beta \in (0,\infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class BetaDistribution;
\end{Verbatim}
The specific algorithm used depends on the parameters. If $\alpha = 1/2$ and
$\beta = 1/2$, or $\alpha = 1$ or $\beta = 1$, then the inverse method is used.
If $\alpha > 1$ and $\beta > 1$, the method in \cite{Cheng:1978jl} is used.
Otherwise, let $K = 0.852$, $C = -0.956$, and $D = \beta + K\alpha^2 + C$. If
$\alpha < 1$, $\beta < 1$ and $D \le 0$, then JÃ¶hnk's method
\parencite[sec.~3.5]{Devroye:1986gi} is used. In all other cases, one of the
switching algorithms in \textcite{Atkinson:1979es} is used. Note that, there is
no vectorized implementation at the moment for the switching algorithms. In
other cases, the vectorized generating shall provide considerable speedup.

\subsubsection{Cauchy distribution}

\begin{equation*}
  f(x;a,b) =
  \frac{1}{\pi b\Round[Big]{1 + \Round[Big]{\frac{x - a}{b}}^2}} \qquad
  x \in \Real,\; a \in \Real,\; b \in (0,\infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class CauchyDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{$\chi^2$-distribution}

\begin{equation*}
  f(x;n) = \frac{x^{n/2 - 1}\EE^{-x/2}}{2^{n/2}\Gamma(n/2)} \qquad
  x \in (0,\infty),\; n \in (0,\infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class ChiSquaredDistribution;
\end{Verbatim}
The implementation uses the fact that if $X$ is a Gamma random variable with
shape $n / 2$ and scale $2$, then $X$ is also $\chi^2$-distributed. See below
for the implementation of the Gamma distribution.

\subsubsection{Exponential distribution}

\begin{equation*}
  f(x;\lambda) = \lambda\EE^{-\lambda x} \qquad
  x \in [0,\infty),\; \lambda \in (0,\infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class ExponentialDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Extreme value distribution}

\begin{equation*}
  f(x;a,b) =
  \frac{1}{b}\exp\Curly[Big]{
    \frac{a - x}{b} - \exp\Curly[Big]{\frac{a - x}{b}}} \qquad
  x \in \Real,\; a \in \Real,\; b \in (0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class ExtremeValueDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Fisher's $F$-distribution}

\begin{align*}
  & f(x;m,n) =
  \frac{\Gamma\Round[Big]{\frac{m + n}{2}}}{
    \Gamma\Round[Big]{\frac{m}{2}}\Gamma\Round[Big]{\frac{n}{2}}}
  \Round[Big]{\frac{m}{n}}^{m/2} x^{m / 2 - 1}
  \Round[Big]{1 + \frac{m}{n}x}^{-(m + n) / 2} \\
  & x \in [0, \infty),\; m \in (0, \infty),\; n \in (0, \infty)
\end{align*}
\begin{Verbatim}
  template <typename RealType = double>
  class FisherFDistribution;
\end{Verbatim}
The implementation uses the fact that if $U$ and $V$ are $\chi^2$-distributed
random variables with degrees of freedom $m$ and $n$, respectively, and they
are independent, then $X = (U / V) / (m / n)$ is a Fisher's $F$-distributed
random variable with the respective degrees of freedom. See above for the
implementation of the $\chi^2$-distribution.

\subsubsection{Gamma distribution}

\begin{equation*}
  f(x;\alpha,\beta) =
  \frac{\EE^{-x/\beta}}{\Gamma(\alpha)}\beta^{-\alpha}x^{\alpha-1} \qquad
  x \in (0, \infty),\; \alpha \in (0, \infty),\; \beta \in (0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class GammaDistribution;
\end{Verbatim}
The specific algorithm used depends on the parameters. If $\alpha = 1$, it
becomes the exponential distribution. If $0 < \alpha < 0.6$, it is generated
through transformation of exponential power distribution
\cite[sec~2.6]{Devroye:1986gi}. If $0.6\le\alpha<1$, then rejection method from
the Weibull distribution is used \parencite[sec.~3.4]{Devroye:1986gi}. If
$\alpha > 1$, then the method in \textcite{Marsaglia:2000vq} is used.

\subsubsection{Laplace distribution}

\begin{equation*}
  f(x;a,b) = \frac{1}{2b}\exp\Curly[Big]{-\frac{\Abs{x - a}}{b}} \qquad
  x \in \Real,\; b \in (0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class LaplaceDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Levy distribution}

\begin{equation*}
  f(x;a,b) =
  \sqrt{\frac{b}{2\pi}}
  \frac{\exp\Curly[Big]{-\frac{b}{2(x - a)}}}{(x - a)^{3/2}} \qquad
  x \in [a, \infty),\; a \in \Real,\; b \in (0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class LevyDistribution;
\end{Verbatim}
The implementation uses the fact that if $Z$ is a standard Normal random
variable, then $X = a + b / Z^2$ is Levy distributed with location $a$ and
scale $b$. See below for the implementation of the Normal distribution.

\subsubsection{Logistic distribution}

\begin{equation*}
  f(x;a,b) = \frac{1}{4b}\mathrm{sech}^2\Round[Big]{\frac{x - a}{2b}} \qquad
  x \in \Real,\; a \in \Real,\; b \in (0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class LaplaceDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Log-normal distribution}

\begin{equation*}
  f(x;m,s) =
  \frac{1}{x\sigma\sqrt{2\pi}}
  \exp\Curly[Big]{-\frac{(\ln x - m)^2}{2\sigma^2}} \qquad
  x \in (0, \infty),\; m \in \Real,\; s \in (0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class LognormalDistribution;
\end{Verbatim}
The implementation uses the fact that if $Z$ is a standard Normal random
variable, then $X = \EE^{m + sZ}$ is Log-normal distributed with location $m$
and scale $s$. See below for the implementation of the Normal distribution.

\subsubsection{Normal distribution}

\begin{equation*}
  f(x;\mu,\sigma) =
  \frac{1}{\sqrt{2\pi\sigma^2}}
  \exp\Curly[Big]{-\frac{(x-\mu)^2}{2\sigma^2}} \qquad
  x \in \Real,\; \mu \in \Real,\; \sigma \in (0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class NormalDistribution;
\end{Verbatim}
The implementation uses the Box-Muller method \cite{Box:1958hv}.

\subsubsection{Pareto distribution}

\begin{equation*}
  f(x;a,b) = \frac{a b^a}{x^{a + 1}} \qquad
  x \in [b, \infty),\; a \in [0, \infty),\; b \in [0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class ParetoDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Rayleigh distribution}

\begin{equation*}
  f(x;\sigma) =
  \frac{x}{\sigma^2}\exp\Curly[Big]{-\frac{x^2}{2\sigma^2}} \qquad
  x \in [0, \infty),\; \sigma \in (0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class RayleighDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Stable distribution}
\begin{align*}
  &f(x;\alpha,\beta,a,b) = \frac{1}{2\pi}\int_{\infty}^{\infty}
  \varphi(t;\alpha,\beta,a,b)\EE^{-ixt}\intd t\\
  &\varphi(t;\alpha,\beta,a,b) = \exp\{ita - \Abs{bt}^{\alpha}(1 -
  i\beta\mathrm{sgn}(t)\Phi(t;\alpha))\} \\
  &\Phi(t;\alpha) = \begin{cases}
    \tan\Round[big]{\frac{\pi}{2}\alpha} & \alpha \ne 1 \\
    -\frac{2}{\pi}\log\Abs{t}            & \alpha = 1
  \end{cases} \\
  & x \in \Real,\;
  \alpha \in (0, 2],\; \beta \in [-1, 1],\; a \in \Real,\; b \in (0, \infty)
\end{align*}
\begin{Verbatim}
  template <typename RealType = double>
  class StableDistribution;
\end{Verbatim}
The implementation uses the method in \cite{Chambers:1976dv}. Note that, some
other distributions implemented in the library, such as the Cauchy distribution
($\alpha = 1$, $\beta = 0$), the Levy distribution ($\alpha = 1/2$, $\beta =
1$), and the Normal distribution ($\alpha = 2$), are all special cases of the
stable distribution. It is possible to use implementations of those
distributions to speed up the stable distribution in special cases. However,
the library does not do so. Every distribution implemented in the library goes
through some basic statistical tests to ensure correctness. Without a tractable
distribution function in general, the stable distribution is somehow more
difficult to test than others. Therefore, we use these special cases to tests
the implementation, which is generic with respect to parameter values. In
applications, for generating random numbers from distributions of those special
cases, use the dedicated classes instead of this one. There are also a few
distributions not implemented by the library, but are special cases of the
stable distribution, such as the Landau distribution ($\alpha = 1$, $\beta =
1$) and Holtsmark distribution ($\alpha = 3/2$, $\beta = 0$), to name just two
of them.

\subsubsection{Student's $t$-distribution}

\begin{equation*}
  f(x;n) =
  \frac{\Gamma\Round[Big]{\frac{n + 1}{2}}}
  {\sqrt{n\pi}\Gamma\Round[Big]{\frac{n}{2}}}
  \Round[Big]{1 + \frac{x^2}{n}}^{-(n + 1)/2} \qquad
  x \in \Real,\; n \in (0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class StudentTDistribution;
\end{Verbatim}
The implementation uses the fact that if $Z$ is a standard Normal random
variable, $V$ is a $\chi^2$-distributed random variable with degree of freedom
$n$, and they are independent, then $X = Z / \sqrt{V / n}$ is Student's
$t$-distributed with the respective degree of freedom. See above for the
implementations of the Normal distribution and the $\chi^2$-distribution.

\subsubsection{Uniform distribution}

\begin{equation*}
  f(x;a,b) = \frac{1}{b - a} \qquad
  x \in [a, b),\; a \in \Real,\; b \in (a, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class UniformRealDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Weibull distribution}

\begin{equation*}
  f(x;a,b) = \frac{a}{b}\Round[Big]{\frac{x}{b}}^{a - 1}
  \exp\Curly[Big]{-\Round[Big]{\frac{x}{b}}^a} \qquad
  x \in [0, \infty),\; a \in (0, \infty),\; b \in (0, \infty)
\end{equation*}
\begin{Verbatim}
  template <typename RealType = double>
  class WeibullDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsection{Discrete distributions}
\label{sub:Discrete distributions}

All discrete distributions support all integer types with sizes at least that
of \verb|short|, unless stated otherwise.

\subsubsection{Bernoulli distribution}

\begin{equation*}
  \Prob(X = k;p) = \begin{cases}
    1 - p &\text{if } k = 0\\
    p     &\text{if } k = 1
  \end{cases} \qquad
  k \in \{0, 1\},\; p \in [0, 1]
\end{equation*}
\begin{Verbatim}
  template <typename IntType = bool>
  class BernoulliDistribution;
\end{Verbatim}
Unlike other discrete distributions, the Bernoulli distribution supports any
integer type, including those with sizes smaller than that of \verb|short|. The
implementation uses the simple fact that if $U$ is a standard uniform random
variable, than $\bbI_{[0,p)}(U)$ is Bernoulli distributed with success
probability $p$. This is not a drop-in replacement for
\verb|std::bernoulli_distribution|, which is not a class template.

\subsubsection{Geometric distribution}

\begin{equation*}
  \Prob(X = k;p) = p(1-p)^k \qquad
  k \in \Natural,\; p \in (0, 1]
\end{equation*}
\begin{Verbatim}
  template <typename IntType = int>
  class GeometricDistribution;
\end{Verbatim}
The implementation uses the fact that if $U$ is a standard uniform random
variable, than $\Floor{\ln U / \ln(1-p)}$ is a Geometric random variable with
success probability $p$.

\subsubsection{Uniform distribution}

\begin{equation*}
  \Prob(X = k;a,b) = \frac{1}{b - a + 1} \qquad
  k \in \{a,\dots,b\},\; a \in \Integer,\; b \in \{x \in \Integer: x \ge a\}
\end{equation*}
\begin{Verbatim}
  template <typename IntType = int>
  class UniformIntDistribution;
\end{Verbatim}
The specific algorithm used depends on the parameters. If $a = b$, then it
simply returns $a$. If $b - a + 1 = 2^W$ where $W$ is the number of bits of
\verb|IntType|, then \verb|UniformBitsDistribution| is used (see
Section~\ref{sub:Uniform bits distribution}). If $\max\{|a|, b\} < 2^{32}$,
then it uses the fact that if $U$ is a standard uniform random variable, then
$\Floor{a + (b - a + 1) U}$ is uniform on the set $\{a,\dots,b\}$. Otherwise,
\verb|std::uniform_int_distribution| is used.

\subsection{Multivariate distributions}
\label{sub:Multivariate distributions}

\subsubsection{Dirichlet distribution}

The library implements the Dirichlet distribution with \pdf,
\begin{equation*}
  f(x_{1:d};\alpha_{1:d}) = \frac{1}{\mathrm{B}(\alpha_{1:d})}
  \prod_{i=1}^d x_i^{\alpha_i - 1}
\end{equation*}
where
\begin{equation*}
  \mathrm{B}(\alpha_{1:d}) =
  \frac{\prod_{i=1}^d\Gamma(\alpha_i)}
  {\Gamma\Round[Big]{\sum_{i=1}^d\alpha_i}}
\end{equation*}
through the class template,
\begin{Verbatim}
  template <
      typename RealType = double,
      size_t Dim = Dynamic>
  class DirichletDistribution;
\end{Verbatim}
The template parameter \verb|Dim| is the dimension of the distribution. If it
is positive, then the dimension is fixed. The distribution generator can be
constructed by,
\begin{Verbatim}
  DirichletDistribution<double, Dim> dirichlet(alpha);
\end{Verbatim}
and if it is zero (recall that \verb|Dynamic| is just an enumerator with value
zero), then the dimension has to be specified at runtime. The distribuiton
generator can be constructed by,
\begin{Verbatim}
  DirichletDistribution<double> dirichlet(dim, alpha);
\end{Verbatim}
The parameter \verb|alpha| can be either a pointer to a $d$-vector or a scalar.
If it is a scalar, say $\alpha$, then $\alpha_i = \alpha$ for $i = 1,\dots,d$.
To generate one random variate,
\begin{Verbatim}
  dirichlet(rng, r);
  rand(rng, dirichlet, r);
\end{Verbatim}
where the output parameter \verb|r| is a pointer to a $d$-vector. Vectorized
generating is also possible. For example,
\begin{Verbatim}
  dirichlet(rng, n, r);
  rand(rng, dirichlet, n, r);
\end{Verbatim}
where the output parameter \verb|r| is a pointer to an $n$ by $d$ matrix of row
major order.

\subsubsection{Multivariate Normal distribution}

The library implements the multivariate Normal distribution with \pdf,
\begin{equation*}
  f(x_{1:d};\mu_{1:d},\Sigma) = \frac{1}{\sqrt{(2\pi)^d\Abs{\Sigma}}}
  \exp\Curly[Big]{-\frac{1}{2}
    (x_{1:d} - \mu_{1:d})^{\transpose}\Sigma^{-1}(x_{1:d} - \mu_{1:d})}
\end{equation*}
where $\mu_{1:d}$ is the mean vector and $\Sigma$ is covariance matrix, through
the class template,
\begin{Verbatim}
  template <typename RealType = double, size_t Dim = Dynamic>
  class NormalMVDistribution;
\end{Verbatim}
At the time of writing, only \verb|float| and \verb|double| are supported types
for the template parameter \verb|RealType|. The second template parameter
\verb|Dim| specify the dimension of the distribution, $d$. If \verb|Dim| is
positive, then the dimension is fixed. The distribution generator can be
constructed by,
\begin{Verbatim}
  NormalMVDistribution<double, Dim> normal_mv(mean, chol);
\end{Verbatim}
Otherwise, if \verb|Dim| is zero, the dimension has to be specified at runtime.
The distribution generator can be constructed by,
\begin{Verbatim}
  NormalMVDistribution<double> normal_mv(d, mean, chol);
\end{Verbatim}
In either case, the parameter \verb|mean| is a pointer to the mean vector of
length $d$, and \verb|chol| is a pointer to the lower triangular of the
Cholesky decomposition of the covariance matrix packed row by row. For those
unfamiliar with matrix storage schemes, this means that, \verb|chol| is a
vector of length $d(d+1)/2$. Let $L$ be the lower triangular of the Cholesky
decomposition, that is $LL^{\transpose} = \Sigma$, then the vector is
$(L_{1,1},L_{2,1},L_{2,2},\dots,L_{d,d})^{\transpose}$. Further, both
\verb|mean| and \verb|chol| can also be scalars instead of pointers to vectors.
If \verb|mean| is a scalar, say $\mu$, then the mean vector is assumed to be a
$d$-vector with all elements equal to $\mu$. If \verb|chol| is a scalar, say
$\sigma$, then it is assumed that $L = \sigma I_d$ and thus the covariance
matrix is $\Sigma = \sigma^2 I_d$, where $I_d$ is the identity matrix. To
generate a single multivariate Normal random number,
\begin{Verbatim}
  normal_mv(rng, r);
  rand(rng, normal_mv, r);
\end{Verbatim}
where the output parameter \verb|r| is a pointer to a $d$-vector. Vectorized
generating is also possible. For example,
\begin{Verbatim}
  normal_mv(rng, n, r);
  rand(rng, normal_mv, n, r);
\end{Verbatim}
where the output parameter \verb|r| is a pointer to an $n$ by $d$ matrix of row
major order.
