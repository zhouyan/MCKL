% ============================================================================
%  MCKL/manual/tex/random.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2016, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Random number generating}
\label{chap:Random number generating}

\mckl has an \rng system for implementing Monte Carlo algorithms. Similar to
the standard library header |<random>|, there are mainly two parts of this
system. The first is a set of \rng engines that generate random integers. The
other is a set of distribution generators. The former are documented in
sections~\ref{sec:Counter-based RNG} to~\ref{sec:MKL RNG}, and the later in
sections~\ref{sec:Uniform bits distribution} to~\ref{sec:Multivariate
  distribution}. There are performance data in appendices~\ref{chap:Performance
of RNG} and~\ref{chap:Performance of distribution} for them. Apart from these,
the library also provides facilities for vectorized random number generating
(section~\ref{sec:Vectorized random number generating}) and using multiple
\rng{}s in parallel programs (section~\ref{sec:Multiple RNG streams}). Last, in
section~\ref{sec:Randomness tests}, a few randomness tests are discussed.

\section{Vectorized random number generating}
\label{sec:Vectorized random number generating}

The generic function |rand| provides vectorized random number generating. There
are two main variants. The first operates on \rng engines and generates random
integers,
\begin{verbatim}
template <typename RNGType>
void rand(RNGType &rng, size_t n, typename RNGType::result_type *r);
\end{verbatim}
The effect of the function call, |rand(rng, n, r)|, is equivalent to the loop,
\begin{verbatim}
for (size_t i = 0; i != n; ++i)
    r[i] = rng();
\end{verbatim}
The results will always be the same unless a non-deterministic \rng is used
(see section~\ref{sec:Non-deterministic RNG}). For some \rng{}s implemented in
\mckl, the vectorized function may have considerable performance advantage. The
second variant of |rand| is for generating distribution random variates,
\begin{verbatim}
template <typename RNGType, typename DistributionType>
void rand(RNGType &rng, const DistributionType &distribution, size_t n,
    typename DistributionType::result_type *r);
\end{verbatim}
For example,
\begin{verbatim}
NormalDistribution<double> normal;
rand(rng, normal, n, r);
\end{verbatim}
This is similar to the following loop,
\begin{verbatim}
for (size_t i = 0; i != n; ++i)
    r[i] = normal(rng);
\end{verbatim}
Depending on the type of |rng| and the distribution (including its parameters),
the vectorized function may have superior performance. However, the results
will not be exactly the same as using a loop, except for the standard uniform
distributions (\ref{sec:Standard uniform distribution}), which will produce
exactly the same results.

For consistency, \mckl also defines variants of the function |rand| for
generating only one random number,
\begin{verbatim}
rand(rng);               // => rng();
rand(rng, distribution); // => distribution(rng);
\end{verbatim}
And each \rng engine and distribution generator also has methods for vectorized
generating,
\begin{verbatim}
rng(n, r);               // => rand(rng, n, r);
distribution(rng, n, r); // => rand(rng, distribution, n, r);
\end{verbatim}
To write generic functions, it is recommended to use the function |rand|
instead of the member methods, since the former also works with classes not
defined by \mckl, such as those in the standard library.

\section{Multiple \texorpdfstring{\rng}{RNG} streams}
\label{sec:Multiple RNG streams}

Earlier in section~\ref{sec:Particle} we introduced that |particle.rng(i)|
returns an independent \rng instance. This is actually done through a class
template called |RNGSet|. Three of them are implemented in \mckl. They all have
the same interface,
\begin{verbatim}
RNGSet<RNG> rng_set(N); // A set of N RNGs
rng_set.resize(n);      // Change the size of the set
rng_set[i];             // Get a reference to the i-th RNG
rng_set.seed();         // Re-seed each RNG in the set
\end{verbatim}
The first implementation is |RNGSetScalar|. As its name suggests, it is only a
wrapper of a single \rng. All calls to |rng_set[i]| returns a reference to the
same \rng. It is only useful when an |RNGSet| interface is required while the
thread-safety and other issues are not important.

The second implementation is |RNGSetVector|. It is an array of \rng{}s with
length~$N$. It has memory cost $O(N)$. Many of the counter-based \rng{}s (see
section~\ref{sec:Counter-based RNG}) have small state sizes and thus for
moderate~$N$, this cost is not significant. The method calls |rng_set[i]| and
|rng_set[j]| return independent \rng{}s if $i \ne j$. This implementation has
the advantage that the behavior of an algorithm can be deterministic and
reproducible (up to rounding errors) even when the scheduling of parallel
execution is dynamic, since each sample has its own \rng.

Last, if \tbb is available, there is a third implementation, |RNGSetTBB|, which
uses thread-local storage (\tls). It has much smaller memory footprint than
|RNGSetVector| while maintains better thread-safety. The performance impact of
using \tls is minimal unless the computation at the calling site is trivial. To
minimize the \tls cost, a reference to the \rng shall be obtained first if it
is used multiple times. For example,
\begin{verbatim}
void eval_each(size_t, ParticleIndex<T> idx)
{
    auto &rng = idx.rng();
    // Use rng
}
\end{verbatim}

The type alias |RNGSet| is defined to be |RNGSetTBB| if \tbb is available,
otherwise it is defined to be |RNGSetVector|. It is used by the |Particle|
class template. One can replace the type of \rng set used by |Particle<T>| with
a member type of |T|. For example,
\begin{verbatim}
class T
{
    public:
    using rng_set_type = RNGSetScalar<RNG>;
};
\end{verbatim}
One can also define their own replacement type, as long as it has the same
interface as the builtin ones.

\section{Counter-based \texorpdfstring{\rng}{RNG}}
\label{sec:Counter-based RNG}

The standard library provides a set of \rng engines. Unfortunately, none of
them are suitable for parallel computing without considerable efforts. The
development by~\cite{Salmon:2011um} made high performance parallel \rng much
more accessible. The \rng{}s introduced in the paper use bijection $f_k$, such
that, for a sequence $\{c_i = i\}_{i\ge0}$, the sequence $\{y_i =
f_k(c_i)\}_{i\ge0}$ appears random. In addition, for $k_1 \ne k_2$, $f_{k_1}$
and $f_{k_2}$ will generate two sequences that appear statistically
independent. Compared to more conventional \rng{}s which use recursions $y_i =
f_k(y_{i - 1})$, these counter-based \rng{}s are much easier to setup in a
parallelized environment. If~$c$, the counter, is an unsigned integer with~$b$
bits, and~$k$, the key, is an unsigned integer with~$d$ bits. Then for each
$k$, the \rng has a period~$2^b$. And there can be at most~$2^d$ independent
streams.

Table~\ref{tab:Counter-based RNG} lists all counter-based \rng{}s implemented
in \mckl, along with the bits of the counter and the key. They all output
32-bit unsigned integers uniform on the set $\{0,\dots,2^{32}-1\}$. For~64-bit
output, a suffix~|_64| may be appended to the corresponding \rng engine names.
For example, |Threefry4x64| and |Threefry4x64_64| both generate the same
256-bit random integers internally. The only difference is that |operator()| of
the former returns~32 of those~256 bits each time it is called, while the later
returns~64 bits.

All \rng{}s in table~\ref{tab:Counter-based RNG} are actually type aliases.
More generally \mckl defines the following class template as the interface,
\begin{verbatim}
template <typename ResultType, typename Generator>
class CounterEngine;
\end{verbatim}
where |ResultType| shall be an unsigned integer type and |Generator| is the
class that actually implements the algorithms. See the reference manual for
details of the generator type. For most users, those implemented in the library
are sufficient. They are introduced in the next few sections. A few
configuration macros of these generators are listed in
table~\ref{tab:Configuration macros for counter-based RNG} and will be referred
to later.

\begin{table}
  \tbfigures
  \begin{tabularx}{\textwidth}{lRR}
    \toprule
    \rng engine & Counter bits & Key bits \\
    \midrule
    \texttt{AES128x1}, \texttt{ARS128x2}, \texttt{AES128x4}, \texttt{AES128x8}
    & 128 & 128 \\
    \texttt{AES192x1}, \texttt{ARS192x2}, \texttt{AES192x4}, \texttt{AES192x8}
    & 128 & 192 \\
    \texttt{AES256x1}, \texttt{AES256x2}, \texttt{AES256x4}, \texttt{AES256x8}
    & 128 & 256 \\
    \texttt{ARSx1},    \texttt{ARSx2},    \texttt{ARSx4},    \texttt{ARSx8}
    & 128 & 128 \\
    \texttt{Philox2x32}    & 64   & 32   \\
    \texttt{Philox2x64}    & 128  & 64   \\
    \texttt{Philox4x32}    & 128  & 64   \\
    \texttt{Philox4x64}    & 256  & 128  \\
    \texttt{Threefry2x32}  & 64   & 64   \\
    \texttt{Threefry2x64}  & 128  & 128  \\
    \texttt{Threefry4x32}  & 128  & 128  \\
    \texttt{Threefry4x64}  & 256  & 256  \\
    \texttt{Threefry8x64}  & 512  & 512  \\
    \texttt{Threefry16x64} & 1024 & 1024 \\
    \bottomrule
  \end{tabularx}
  \caption{Counter-based \rng}
  \label{tab:Counter-based RNG}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LL}
    \toprule
    Macro & Default \\
    \midrule
    \texttt{MCKL\_AES128\_ROUNDS}           & 10 \\
    \texttt{MCKL\_AES192\_ROUNDS}           & 12 \\
    \texttt{MCKL\_AES256\_ROUNDS}           & 14 \\
    \texttt{MCKL\_ARS\_ROUNDS}              & 5  \\
    \texttt{MCKL\_AESNI\_BLOCKS}            & 8  \\
    \texttt{MCKL\_PHILOX\_ROUNDS}           & 10 \\
    \texttt{MCKL\_PHILOX\_VECTOR\_LENGTH}   & 4  \\
    \texttt{MCKL\_THREEFRY\_ROUNDS}         & 20 \\
    \texttt{MCKL\_THREEFRY\_VECTOR\_LENGTH} & 4  \\
    \bottomrule
  \end{tabularx}
  \caption{Configuration macros for counter-based \rng}
  \label{tab:Configuration macros for counter-based RNG}
\end{table}

\subsection{\texorpdfstring{\aesni}{AES-NI} instructions based
\texorpdfstring{\rng}{RNG}}
\label{sub:AES-NI instructions based RNG}

\aesni\footnote{\url{https://en.wikipedia.org/wiki/AES_instruction_set}}
instructions based \rng{}s in~\cite{Salmon:2011um} are implemented in the
following generator,
\begin{verbatim}
template <typename KeySeqType, size_t Rounds, size_t Blocks>
class AESNIGenerator;
\end{verbatim}
The corresponding \rng engine is,
\begin{verbatim}
template <typename ResultType, typename KeySeqType, size_t Rounds, size_t Blocks>
using AESNIEngine =
    CounterEngine<ResultType, AESNIGenerator<KeySeqType, Rounds, Blocks>>;
\end{verbatim}
where |KeySeqType| is the class used to generate the sequences of round keys.
The parameter |Rounds| is the number of rounds of \aes encryption to be
performed. See the reference manual for details of how to define the key
sequence class. \aesni encryption instructions have a latency of seven or eight
cycles, while they can be issued at every cycle. Therefore better performance
can be achieved if multiple~128-bit random integers are generated at the same
time. This is specified by the template parameter |Blocks|. Larger blocks, up
to eight, might improve performance. But this is at the cost of larger state
size. Without going into details, there are four types of sequence of round
keys implemented by \mckl,
\begin{verbatim}
template <size_t Rounds>
using AES128KeySeq = internal::AESKeySeq<Rounds, internal::AES128KeySeqGenerator>;

template <size_t Rounds>
using AES192KeySeq = internal::AESKeySeq<Rounds, internal::AES192KeySeqGenerator>;

template <size_t Rounds>
using AES256KeySeq = internal::AESKeySeq<Rounds, internal::AES256KeySeqGenerator>;

template <typename Constants = ARSConstants>
using ARSKeySeq = internal::ARSKeySeqImpl<Constants>;
\end{verbatim}
and correspondingly four \rng engines,
\begin{verbatim}
template <typename ResultType, size_t Rounds = MCKL_AES128_ROUNDS,
    size_t Blocks = MCKL_AESNI_BLOCKS>
using AES128Engine = AESNIEngine<ResultType, AES128KeySeq<Rounds>, Rounds, Blocks>;

template <typename ResultType, size_t Rounds = MCKL_AES192_ROUNDS,
    size_t Blocks = MCKL_AESNI_BLOCKS>
using AES192Engine = AESNIEngine<ResultType, AES192KeySeq<Rounds>, Rounds, Blocks>;

template <typename ResultType, size_t Rounds = MCKL_AES256_ROUNDS,
    size_t Blocks = MCKL_AESNI_BLOCKS>
using AES256Engine = AESNIEngine<ResultType, AES256KeySeq<Rounds>, Rounds, Blocks>;

template <typename ResultType, size_t Rounds = MCKL_ARS_ROUNDS,
    size_t Blocks = MCKL_AESNI_BLOCKS, typename Constants = ARSConstants>
using ARSEngine = AESNIEngine<ResultType, ARSKeySeq<Constants>, Rounds, Blocks>;
\end{verbatim}
The first three are equivalent to \aes-128, \aes-192 and \aes-256 block ciphers
used in counter mode. The last is the \ars algorithm introduced
by~\cite{Salmon:2011um}. The template parameter |Constants| of |ARSKeySeq| and
|ARSEngine| is a trait class that defines the constants of the Weyl's sequence.
See~\cite{Salmon:2011um} for details. The defaults are taken from the paper. To
use an alternative pair of~64-bit integers as the constants, one can define and
use a trait class as the following,
\begin{verbatim}
template <size_t>
struct NewWeylConstant;

template<>
struct NewWeylConstant<0>
{
    static constexpr uint64_t value = FIRST_CONSTANT;
};

template<>
struct NewWeylConstant<1>
{
    static constexpr uint64_t value = SECOND_CONSTANT;
};

struct NewConstants
{
    template <size_t I>
    using weyl = NewWeylConstant<I>;
};

using NewARS = ARSEngine<ResultType, Rounds, NewConstants>;
\end{verbatim}
Alternative methods are also possible. The only requirement is that, the
following statement,
\begin{verbatim}
template <size_t I>
using weyl = typename Constants::template weyl<I>;
\end{verbatim}
shall define the type |weyl| such that it has a static constant expression
member data |value| that is the~$i$\ith Weyl constant. A few type aliases are
defined for convenience. For example,
\begin{verbatim}
using ARSx8    = ARSEngine<uint32_t, MCKL_ARS_ROUNDS, 8>;
using ARSx8_64 = ARSEngine<uint64_t, MCKL_ARS_ROUNDS, 8>;
using ARS      = ARSEngine<uint32_t>;
using ARS_64   = ARSEngine<uint64_t>;
\end{verbatim}
The engine |ARS| is the default \rng if \aesni instructions are supported.
Aliases for block sizes~1, 2, 4 and~8 are defined for all four algorithms, as
well as both~32- and~64-bit output variants. These aliases are listed in
table~\ref{tab:Counter-based RNG}. The performance of these engines depends on
a few factors, such as \cpu types, compilers, operating systems, etc. In any
case, the performance is good enough even for the most demanding applications.
\mckl does not attempt to optimize the algorithm for any particular platform.
In realistic applications, the performance of \rng is unlikely to become a
bottle neck. Note that, the best performance is obtained with the vectorized
|rand| function (see section~\ref{sec:Vectorized random number generating}).

\subsection{Philox}
\label{sub:Philox}

The Philox algorithm in~\cite{Salmon:2011um} is implemented in the following
generator,
\begin{verbatim}
template <typename T, size_t K = MCKL_PHILOX_VECTOR_LENGTH,
    size_t Rounds = MCKL_PHILOX_ROUNDS, typename Constants = PhiloxConstants<T, K>>
class PhiloxGenerator;
\end{verbatim}
The corresponding \rng engine is,
\begin{verbatim}
template <typename ResultType, typename T = ResultType,
    size_t K = MCKL_PHILOX_VECTOR_LENGTH, size_t Rounds = MCKL_PHILOX_ROUNDS,
    typename Constants = PhiloxConstants<T, K>>
using PhiloxEngine =
    CounterEngine<ResultType, PhiloxGenerator<T, K, Rounds, Constants>>;
\end{verbatim}
The default vector length and the number of rounds can be changed by
configuration macros listed in table~\ref{tab:Configuration macros for
counter-based RNG}. There is no limit on the template parameter |K| or
|Rounds|, nor any limitation on |T| except that it has to be an unsigned
integer type. See~\cite{Salmon:2011um} for the most general form of the
algorithm. However, \mckl only provides default constants for~32- and~64-bit
unsigned integer types as |T| and |K| taking the values~2 or~4. These four
engines are defined as type aliases for convenience,
\begin{verbatim}
template <typename ResultType>
using Philox2x32Engine = PhiloxEngine<ResultType, uint32_t, 2>;

template <typename ResultType>
using Philox4x32Engine = PhiloxEngine<ResultType, uint32_t, 4>;

template <typename ResultType>
using Philox2x64Engine = PhiloxEngine<ResultType, uint64_t, 2>;

template <typename ResultType>
using Philox4x64Engine = PhiloxEngine<ResultType, uint64_t, 4>;
\end{verbatim}
Type aliases for~32- and~64-bit |ResultType| are also defined, as listed in
table~\ref{tab:Counter-based RNG}. To use the engine with |K| taking values
larger than four, or |T| being unsigned integer type with the number of bits
other than~32 or~64, one needs to provide a suitable trait class, |Constant|.
It is similar to that of |ARSEngine|. See the reference manual of
|PhiloxConstants| for an example of how to define it.

\subsection{Threefry}
\label{sub:Threefry}

The Threefry algorithm in~\cite{Salmon:2011um} is implemented in the following
generator,
\begin{verbatim}
template <typename T, size_t K = MCKL_THREEFRY_VECTOR_LENGTH,
    size_t Rounds = MCKL_THREEFRY_ROUNDS,
    typename Constants = ThreefryConstants<T, K>>
class ThreefryGenerator;
\end{verbatim}
The corresponding \rng engine is,
\begin{verbatim}
template <typename ResultType, typename T = ResultType,
    size_t K = MCKL_THREEFRY_VECTOR_LENGTH, size_t Rounds = MCKL_THREEFRY_ROUNDS,
    typename Constants = ThreefryConstants<T, K>>
using ThreefryEngine =
    CounterEngine<ResultType, ThreefryGenerator<T, K, Rounds, Constants>>;
\end{verbatim}
The default vector length and the number of rounds can be changed by
configuration macros listed in table~\ref{tab:Configuration macros for
counter-based RNG}. Similar to the implementation of the Philox algorithm,
there is no limit on the template parameter |K| or |Rounds| as long as a
suitable trait class |Constant| is provided. \mckl provides default constants
for~64-bit unsigned integer type as |T| and |K| taking the values~4, 8 and~16,
taken from the skein\footnote{\url{http://www.skein-hash.info}} hash algorithm,
for which the Threefish algorithm was originally developed for. Defaults for
32-bit |T| or |K| taking the value~2 are also provided, taken
from~\cite{Salmon:2011um}. Type aliases for these configurations are defined
for convenience, Type aliases for~32- and~64-bit |ResultType| are also defined,
as listed in table~\ref{tab:Counter-based RNG}.
\begin{verbatim}
template <typename ResultType>
using Threefry2x32Engine = ThreefryEngine<ResultType, uint32_t, 2>;

template <typename ResultType>
using Threefry4x32Engine = ThreefryEngine<ResultType, uint32_t, 4>;

template <typename ResultType>
using Threefry2x64Engine = ThreefryEngine<ResultType, uint64_t, 2>;

template <typename ResultType>
using Threefry4x64Engine = ThreefryEngine<ResultType, uint64_t, 4>;

template <typename ResultType>
using Threefry8x64Engine = ThreefryEngine<ResultType, uint64_t, 8>;

template <typename ResultType>
using Threefry16x64Engine = ThreefryEngine<ResultType, uint64_t, 16>;
\end{verbatim}

\subsection{Seeding counter-based \texorpdfstring{\rng}{RNG}}
\label{sub:Seeding counter-based RNG}

The singleton class template |SeedGenerator| can be used to generate
distinctive seeds sequentially. For example,
\begin{verbatim}
auto &seed = SeedGenerator<void, unsigned>::instance();
RNG rng1(seed.get()); // Construct rng1
RNG rng2(seed.get()); // Construct rng2 with another seed
\end{verbatim}
The first parameter of the template can be any type. For different types,
different instances of |SeedGenerator| will be created. Thus, the seeds
generated by two generators, |SeedGenerator<T1>| and |SeedGenerator<T2>|, will
be distinctive. The second parameter is the type of the seed values. It can be
any unsigned integer type. Classes such as |Particle<T>| will use the generator
of the following type,
\begin{verbatim}
using Seed = SeedGenerator<NullType, MCKL_SEED_RESULT_TYPE>;
\end{verbatim}
where |MCKL_SEED_RESULT_TYPE| is a configuration macro which is defined to
|unsigned| by default.

One can save and set the seed generator using standard streams. For example,
\begin{verbatim}
std::ifstream is("seed.txt");
if (is)
    is >> Seed::instance();    // Read seed from a file
else
    Seed::instance().set(101); // Set it manually
is.close();
// Using Seed
std::ofstream os("seed.txt");
os << Seed::instance();        // Write the seed to a file
os.close();
\end{verbatim}
This way, if the simulation program needs to be repeated multiple times, each
time it will use a different set of seeds. A single seed generator is enough
for a single program. However, it is more difficult to ensure that each
computing node has a distinctive set of seeds in a distributed system. A simple
solution is to use the |modulo| method of |SeedGenerator|. For example,
\begin{verbatim}
Seed::instance().modulo(n, r);
\end{verbatim}
where~$n$ is the number of processes and~$r$ is the rank of the current node.
After this call, all seeds generated will belong to the equivalent class $s
\equiv r \mod n$. Therefore, no two nodes will ever generate the same seeds.
Note that, the seeds generated are not random at all. For any deterministic
\rng{}s, the same seeds always produce identical streams. However, distinctive
seeds does not always lead to independent streams. This seed generator is only
suitable for counter-based \rng{}s.

\section{Non-deterministic \texorpdfstring{\rng}{RNG}}
\label{sec:Non-deterministic RNG}

If \rdrand\footnote{\url{https://en.wikipedia.org/wiki/RdRand}} instructions
are supported, \mckl also implements three non-deterministic \rng{}s,
|RDRAND16|, |RDRAND32| and |RDRAND64|. They output~16-, 32-, and~64-bit random
integers, respectively. \rdrand instructions may not return a random integer at
all. The \rng engine will keep trying until it succeeds. One can limit the
maximum number of trials by defining the configuration macro
|MCKL_RDRAND_NTRIAL_MAX|. A value of zero, the default, means the number of
trials is unlimited. If it is a positive number, and if after the specified
number of trials no random integer is returned by \rdrand instructions, zero is
returned.

\section{\texorpdfstring{\mkl \rng}{MKL RNG}}
\label{sec:MKL RNG}

\mkl provides some high performance \rng{}s. \mckl implements a wrapper class
|MKLEngine| that makes them accessible as \cpp engines. They are listed in
table~\ref{tab:MKL RNG}. Note that, \mkl \rng{}s perform the best when they
are used to generate vectors of random numbers. These wrappers use a buffer to
store such vectors. And thus they have much larger state space than usual
\rng{}s. Each \rng engine outputs by default~32-bit integers. Similar to the
counter-based \rng{}s, 64-bit variants are also defined with a suffix~|_64|.

When there are \mkl routines for generating distribution random variates for
one of the distributions discussed later in sections~\ref{sec:Continuous
distribution} and~\ref{sec:Discrete distribution}, the library will
automatically use these routines for vectorized random number generating if the
\rng is one of that listed in table~\ref{tab:MKL RNG} (and their~64-bit
variants). For example,
\begin{verbatim}
MKL_SFMT19937 rng;
NormalDistribution<double> normal;
normal(rng, n, r);       // MKL rountines used
rand(rng, normal, n, r); // MKL rountines used
\end{verbatim}
Note that, this is applicable when the distribution is a class in \mckl.
It will not work with classes such as |std::normal_distribution|. This is also
applicable when the distribution is not directly supported by \mkl, but can be
easily generated using other distributions, e.g., the Student's
$t$-distribution. In addition, it is also applicable if a distribution is a
special case of one of the distributions supported by \mkl, e.g., the
$\chi^2$-distribution.

\begin{table}
  \begin{tabularx}{\textwidth}{LL}
    \toprule
    \rng engine & \mkl \brng \\
    \midrule
    \texttt{MKL\_MCG59}         & \texttt{VSL\_BRNG\_MCG59}         \\
    \texttt{MKL\_MT19937}       & \texttt{VSL\_BRNG\_MT19937}       \\
    \texttt{MKL\_MT2203}        & \texttt{VSL\_BRNG\_MT2203}        \\
    \texttt{MKL\_SFMT19937}     & \texttt{VSL\_BRNG\_SFMT19937}     \\
    \texttt{MKL\_NONDETERM}     & \texttt{VSL\_BRNG\_NONDETERM}     \\
    \texttt{MKL\_ARS5}          & \texttt{VSL\_BRNG\_ARS5}          \\
    \texttt{MKL\_PHILOX4X32X10} & \texttt{VSL\_BRNG\_PHILOX4X32X10} \\
    \bottomrule
  \end{tabularx}
  \caption{\mkl \rng}
  \label{tab:MKL RNG}
\end{table}

\section{Uniform bits distribution}
\label{sec:Uniform bits distribution}

The class template,
\begin{verbatim}
template <typename UIntType>
class UniformBitsDistribution;
\end{verbatim}
is similar to the standard library's |std::independent_bits_engine|, except
that it always generates full size random integers and |UIntType| must have
size at least of that of |short|. That is, let~$W$ be the number of bits of
|UIntType|, then the output is uniform on the set $\{0,\dots,2^W - 1\}$. For
example,
\begin{verbatim}
UniformBitsDistribution<uint32_t> ubits;
ubits(rng); // Return 32-bit random integers
\end{verbatim}
Let $\rmin$ and $\rmax$ be the minimum and maximum of the random integers
generated by |rng|. Let $R = \rmax - \rmin + 1$. Let $r_i$ be consecutive
output of |rng()|. If there exists an integer $V > 0$ such that $R = 2^V$, then
the result is,
\begin{equation*}
  U = \sum_{k = 0}^{K - 1} (r_k - \rmin) 2^{kV} \bmod 2^W
\end{equation*}
where $K = \Ceil{W / V}$. Unlike |std::independent_bits_engine|, the
calculation can be vectorized, which leads to better performance. Note that,
all constants in the algorithm are computed at compile-time and the summation
is fully unrolled. There is no runtime overhead. In the case $\rmin = 0$ and $V
= W$, most optimizing compilers shall be able to generate instructions such
that the distribution does exactly nothing and returns the results of |rng()|
directly. If there does not exist an integer $V > 0$ such that $R = 2^V$, then
|std::indepdent_bits_engine| will be used.

\section{Standard uniform distribution}
\label{sec:Standard uniform distribution}

\mckl provides five standard uniform distributions. They are all class
templates with a single template type parameter |RealType|. The random integers
produced by \rng{}s are transferred to~32- or~64-bit random integers through
the class |UniformBitsDistribution| before they are mapped to floating point
numbers within the interval $[0, 1]$. The integer type depends on |RealType|,
the range of the \rng{}, $R$, and |MCKL_U01_USE_64BITS_DOUBLE|, a configuration
macro. The exact relations are listed in table~\ref{tab:Intermediate integer
types of uniform distribution}. In the following, let~$W$ be the number of bits
of the integer type, and~$M$ be the number of significant bits (including the
implicit one) of |RealType|. We also denote the input random integers as~$U$
and the output random real numbers as~$X$.

\begin{table}
  \begin{tabularx}{\textwidth}{LlL}
    \toprule
    \texttt{RealType} & Conditions & Integer type \\
    \midrule
    \texttt{float}  & $\log_2 R \ge 64$ & \texttt{uint64\_t} \\
                    & Otherwise         & \texttt{uint32\_t} \\
    \texttt{double} & $\log_2 R \ge 64$ & \texttt{uint64\_t} \\
    & \texttt{MCKL\_U01\_USE\_64BITS\_DOUBLE} & \texttt{uint64\_t} \\
    & Otherwise & \texttt{uint32\_t} \\
    \texttt{long double} & Always & \texttt{uint64\_t} \\
    \bottomrule
  \end{tabularx}
  \caption{Intermediate integer types of uniform distribution}
  \label{tab:Intermediate integer types of uniform distribution}
\end{table}

\subsection{Standard form}
\label{sub:Standard form}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01Distribution;
\end{verbatim}
implements the uniform distribution on $[0, 1)$. If |MCKL_U01_USE_FIXED_POINT|
  is true, which is the default, then it is an alias to |U01CODistribution|
  (section~\ref{sub:Closed-open interval}). Otherwise, it is implemented
  through the mapping,
\begin{equation*}
  P = \Floor{(W + M - 1) / W},\qquad
  K = \max\{1, P\},\qquad
  X = \sum_{k=0}^{K - 1} U_k 2^{-(K - k)W}
\end{equation*}

\subsection{Closed-closed interval}
\label{sub:Closed-closed interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CCDistribution;
\end{verbatim}
implements the uniform distribution on $[0, 1]$ through the mapping,
\begin{align*}
  P &= \min\{W - 1, M\} \\
  V &= \begin{cases}
    U &\text{if } P + 1 < W \\
    \Floor{(U \bmod 2^{W - 1}) / 2^{W - P -2}} &\text{otherwise}
  \end{cases} \\
  Z &= (V \bmod 2) + V \\
  X &= 2^{-(P + 1)} Z.
\end{align*}
The minimum and maximum are~$0$ and~$1$, respectively.

\subsection{Closed-open interval}
\label{sub:Closed-open interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CODistribution;
\end{verbatim}
implements the uniform distribution on $[0, 1)$ through the mapping,
\begin{equation*}
  P = \min\{W, M\},\qquad
  V = \Floor{U / 2^{W - P}},\qquad
  X = 2^{-P} V
\end{equation*}
The minimum and maximum are~$0$ and~$1 - 2^{-P}$, respectively.

\subsection{Open-closed interval}
\label{sub:Open-closed interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01OCDistribution;
\end{verbatim}
implements the uniform distribution on $(0, 1]$ through the mapping,
\begin{equation*}
  P = \min\{W, M\},\qquad
  V = \Floor{U / 2^{W - P}},\qquad
  X = 2^{-P} V + 2^{-P}
\end{equation*}
The minimum and maximum are~$2^{-P}$ and~$1$, respectively.

\subsection{Open-open interval}
\label{sub:Open-open interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CODistribution;
\end{verbatim}
implements the uniform distribution on $(0, 1)$ through the mapping,
\begin{equation*}
  P = \min\{W + 1, M\},\qquad
  V = \Floor{U / 2^{W + 1 - P}},\qquad
  X = 2^{-(P - 1)} V + 2^{-P}
\end{equation*}
The minimum and maximum are~$2^{-P}$ and~$1 - 2^{-P}$, respectively.

\subsection{Performance and accuracy considerations}
\label{sub:Performance and accuracy considerations}

The distributions in sections~\ref{sub:Closed-closed interval}
to~\ref{sub:Open-open interval} actually produce ``fixed point'' numbers. The
output~$X$ can be represented exactly by the target |RealType|. They have two
advantages. First, when it is important that the lower or upper bound is never
produced, to avoid underflow, overflow or other undefined behaviors in
subsequent calculations, they provide such assurance. The implementation of the
other distributions discussed later rely on these behaviors to avoid producing
indefinite numbers. Second, they usually can be executed with only a couple of
instructions by modern processors. And thus can have better performance.

The main drawback is accuracy. If |RealType| is |float| or |long double|, then
the difference is minimal, since the random integers have more bits than the
significant of the target floating point types. The situation is a bit more
tricky when the output type is |double| and the integer type has only~32 bits.
In this case, |U01CODistribution|, etc., can only produce~$2^{32}$ distinctive
values while |double| can represent much more values exactly within the range
$[0, 1]$. In contrast, the standard library will use at least~53 random bits.
This will not matter in many realistic applications. In fact, random numbers
produced by |U01CODistribution|, etc., passes all tests in the \testu
library~\cite{Lecuyer:2007hv} that |std::uniform_real_distribution| would pass,
for a good \rng. In other words, the quality of the \rng is the dominating
factor.

However, there are situations where one does want the extra precision. In this
case, one can define |MCKL_U01_USE_64BITS_DOUBLE| to be true, such that the
random integers will always be~64-bit for |double| output.

\section{Continuous distribution}
\label{sec:Continuous distribution}

\subsection{Arcsine distribution}
\label{sub:Arcsine distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ArcsineDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\alpha,\beta) = \frac{1}{\pi\sqrt{(x - \alpha)(\beta - x)}},\qquad
  x \in [a, b],\quad a \in (0,\infty),\quad b \in (0,\infty),
\end{equation*}
using the inverse method.

\subsection{Beta distribution}
\label{sub:Beta distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class BetaDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\alpha,\beta) =
  \frac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)}
  x^{\alpha - 1}(1 - x)^{\beta - 1},\qquad
  x \in (0, 1),\quad \alpha \in (0,\infty),\quad \beta \in (0,\infty).
\end{equation*}
The specific algorithm used depends on the parameters. If $\alpha = 1/2$ and
$\beta = 1/2$, or $\alpha = 1$ or $\beta = 1$, then the inverse method is used.
If $\alpha > 1$ and $\beta > 1$, the method in~\cite{Cheng:1978jl} is used.
Otherwise, let $K = 0.852$, $C = -0.956$, and $D = \beta + K\alpha^2 + C$. If
$\alpha < 1$, $\beta < 1$ and $D \le 0$, then JÃ¶hnk's
method~\cite[sec.~3.5]{Devroye:1986gi} is used. In all other cases, one of the
switching algorithms in~\cite{Atkinson:1979es} is used. Note that, there is no
vectorized implementation at the moment for the switching algorithms. In other
cases, the vectorized generating shall provide considerable speedup.

\subsection{Cauchy distribution}
\label{sub:Cauchy distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class CauchyDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) =
  \frac{1}{\pi b\Round[Big]{1 + \Round[Big]{\frac{x - a}{b}}^2}},\qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0,\infty),
\end{equation*}
using the inverse method.

\subsection{\texorpdfstring{$\chi^2$}{Chi-squared}-distribution}
\label{Chi-squared-distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ChiSquaredDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;n) = \frac{x^{n/2 - 1}\EE^{-x/2}}{2^{n/2}\Gamma(n/2)},\qquad
  x \in (0,\infty),\quad n \in (0,\infty),
\end{equation*}
The implementation uses the fact that if~$X$ is a Gamma random variable with
shape $n / 2$ and scale~$2$, then~$X$ is also $\chi^2$-distributed.

\subsection{Exponential distribution}
\label{sub:Exponential distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ExponentialDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\lambda) = \lambda\EE^{-\lambda x},\qquad
  x \in [0,\infty),\quad \lambda \in (0,\infty),
\end{equation*}
using the inverse method.

\subsection{Extreme value distribution}
\label{sub:Extreme value distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ExtremeValueDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) =
  \frac{1}{b}\exp\Curly[Big]{
    \frac{a - x}{b} - \exp\Curly[Big]{\frac{a - x}{b}}},\qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Fisher's \texorpdfstring{$F$}{F}-distribution}
\label{sub:Fisher's F-distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class FisherFDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{align*}
  & f(x;m,n) =
  \frac{\Gamma\Round[Big]{\frac{m + n}{2}}}{
    \Gamma\Round[Big]{\frac{m}{2}}\Gamma\Round[Big]{\frac{n}{2}}}
  \Round[Big]{\frac{m}{n}}^{m/2} x^{m / 2 - 1}
  \Round[Big]{1 + \frac{m}{n}x}^{-(m + n) / 2} \\
  & x \in [0, \infty),\quad m \in (0, \infty),\quad n \in (0, \infty).
\end{align*}
The implementation uses the fact that if~$U$ and~$V$ are $\chi^2$-distributed
random variables with degrees of freedom~$m$ and~$n$, respectively, and they
are independent, then
\begin{equation*}
  X = \frac{U / V}{m / n}
\end{equation*}
is a Fisher's $F$-distributed random variable with the respective degrees of
freedom.

\subsection{Gamma distribution}
\label{sub:Gamma distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class GammaDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\alpha,\beta) =
  \frac{\EE^{-x/\beta}}{\Gamma(\alpha)}\beta^{-\alpha}x^{\alpha-1},\qquad
  x \in (0, \infty),\quad \alpha \in (0, \infty),\quad \beta \in (0, \infty).
\end{equation*}
The specific algorithm used depends on the parameters. If $\alpha = 1$, it
becomes the exponential distribution. If $0 < \alpha < 0.6$, it is generated
through transformation of exponential power
distribution~\cite[sec~2.6]{Devroye:1986gi}. If $0.6\le\alpha<1$, then
rejection method from the Weibull distribution is
used~\cite[sec.~3.4]{Devroye:1986gi}. If $\alpha > 1$, then the method
in~\cite{Marsaglia:2000vq} is used.

\subsection{Laplace distribution}
\label{sub:Laplace distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LaplaceDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{1}{2b}\exp\Curly[Big]{-\frac{\Abs{x - a}}{b}},\qquad
  x \in \Real,\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Levy distribution}
\label{sub:Levy distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LevyDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) =
  \sqrt{\frac{b}{2\pi}}
  \frac{\exp\Curly[Big]{-\frac{b}{2(x - a)}}}{(x - a)^{3/2}},\qquad
  x \in [a, \infty),\quad a \in \Real,\quad b \in (0, \infty).
\end{equation*}
The implementation uses the fact that if~$Z$ is a standard Normal random
variable, then
\begin{equation*}
  X = a + b / Z^2
\end{equation*}
is Levy distributed with location~$a$ and scale~$b$.

\subsection{Logistic distribution}
\label{sub:Logistic distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LaplaceDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{1}{4b}\mathrm{sech}^2\Round[Big]{\frac{x - a}{2b}},\qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Log-normal distribution}
\label{sub:Log-normal distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LognormalDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;m,s) =
  \frac{1}{x\sigma\sqrt{2\pi}}
  \exp\Curly[Big]{-\frac{(\ln x - m)^2}{2\sigma^2}},\qquad
  x \in (0, \infty),\quad m \in \Real,\quad s \in (0, \infty).
\end{equation*}
The implementation uses the fact that if~$Z$ is a standard Normal random
variable, then
\begin{equation*}
  X = \exp\{m + sZ\}
\end{equation*}
is Log-normal distributed with location~$m$ and scale~$s$.

\subsection{Normal distribution}
\label{sub:Normal distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class NormalDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\mu,\sigma) =
  \frac{1}{\sqrt{2\pi\sigma^2}}
  \exp\Curly[Big]{-\frac{(x-\mu)^2}{2\sigma^2}},\qquad
  x \in \Real,\quad \mu \in \Real,\quad \sigma \in (0, \infty),
\end{equation*}
using the Box-Muller method~\cite{Box:1958hv}.

\subsection{Pareto distribution}
\label{sub:Pareto distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ParetoDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{a b^a}{x^{a + 1}},\qquad
  x \in [b, \infty),\quad a \in [0, \infty),\quad b \in [0, \infty),
\end{equation*}
using the inverse method.

\subsection{Rayleigh distribution}
\label{sub:Rayleigh distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class RayleighDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\sigma) =
  \frac{x}{\sigma^2}\exp\Curly[Big]{-\frac{x^2}{2\sigma^2}},\qquad
  x \in [0, \infty),\quad \sigma \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Stable distribution}
\label{sub:Stable distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class StableDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{align*}
  &f(x;\alpha,\beta,a,b) =
  \frac{1}{2\pi}\int_{\infty}^{\infty}
  \varphi(t;\alpha,\beta,a,b)\EE^{-ixt}\intd t\\
  &\varphi(t;\alpha,\beta,a,b) =
  \exp\{ita - \Abs{bt}^{\alpha}(1 - i\beta\mathrm{sgn}(t)\Phi(t;\alpha))\} \\
  &\Phi(t;\alpha) = \begin{cases}
    \tan\Round[big]{\frac{\pi}{2}\alpha} & \alpha \ne 1 \\
    -\frac{2}{\pi}\log\Abs{t}            & \alpha = 1
  \end{cases} \\
  & x \in \Real,\quad
  \alpha \in (0, 2],\quad \beta \in [-1, 1],\quad
  a \in \Real,\quad b \in (0, \infty).
\end{align*}
The implementation uses the method in~\cite{Chambers:1976dv}. Note that, some
other distributions implemented in \mckl, such as the Cauchy distribution
($\alpha = 1$, $\beta = 0$), the Levy distribution ($\alpha = 1/2$, $\beta =
1$), and the Normal distribution ($\alpha = 2$), are all special cases of the
stable distribution. It is possible to use implementations of those
distributions to speed up the stable distribution in special cases. However,
\mckl does not do so. Every distribution implemented in \mckl goes through some
basic statistical tests to ensure correctness. Without a tractable distribution
function in general, the stable distribution is somehow more difficult to test
than others. Therefore, we use these special cases to tests the implementation,
which is generic with respect to parameter values. In applications, for
generating random numbers from distributions of those special cases, use the
dedicated classes instead of this one. There are also a few distributions not
implemented by \mckl, but are special cases of the stable distribution, such as
the Landau distribution ($\alpha = 1$, $\beta = 1$) and Holtsmark distribution
($\alpha = 3/2$, $\beta = 0$), to name just two of them.

\subsection{Student's \texorpdfstring{$t$}{t}-distribution}
\label{sub:Student's t-distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class StudentTDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;n) =
  \frac{\Gamma\Round[Big]{\frac{n + 1}{2}}}
  {\sqrt{n\pi}\Gamma\Round[Big]{\frac{n}{2}}}
  \Round[Big]{1 + \frac{x^2}{n}}^{-(n + 1)/2},\qquad
  x \in \Real,\quad n \in (0, \infty).
\end{equation*}
The implementation uses the fact that if~$Z$ is a standard Normal random
variable, $V$ is a $\chi^2$-distributed random variable with degree of freedom
$n$, and they are independent, then
\begin{equation*}
  X = \frac{Z}{\sqrt{V / n}}
\end{equation*}
is Student's $t$-distributed with the respective degree of freedom.

\subsection{Uniform real distribution}
\label{sub:Uniform real distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class UniformRealDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{1}{b - a},\qquad
  x \in [a, b),\quad a \in \Real,\quad b \in (a, \infty),
\end{equation*}
using the inverse method.

\subsection{Weibull distribution}
\label{sub:Weibull distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class WeibullDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{a}{b}\Round[Big]{\frac{x}{b}}^{a - 1}
  \exp\Curly[Big]{-\Round[Big]{\frac{x}{b}}^a},\qquad
  x \in [0, \infty),\quad a \in (0, \infty),\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\section{Discrete distribution}
\label{sec:Discrete distribution}

\subsection{Bernoulli distribution}
\label{sub:Bernoulli distribution}

The class template,
\begin{verbatim}
template <typename IntType = bool>
class BernoulliDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  \Prob(X = k;p) = kp + (1 - k)(1 - p),\qquad
  k \in \{0, 1\},\quad p \in [0, 1].
\end{equation*}
Unlike other discrete distributions, the Bernoulli distribution supports any
integer type, including those with sizes smaller than that of |short|. The
implementation uses the simple fact that if~$U$ is a standard uniform random
variable, than $\bbI_{[0,p)}(U)$ is Bernoulli distributed with success
probability~$p$. This is not a drop-in replacement for
|std::bernoulli_distribution|, which is not a class template.

\subsection{Geometric distribution}
\label{sub:Geometric distribution}

The class template,
\begin{verbatim}
template <typename IntType = int>
class GeometricDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  \Prob(X = k;p) = p(1-p)^k,\qquad
  k \in \Natural,\quad p \in (0, 1].
\end{equation*}
The implementation uses the fact that if~$U$ is a standard uniform random
variable, than
\begin{equation*}
  X = \Floor{\ln U / \ln(1-p)}
\end{equation*}
is a Geometric random variable with success probability~$p$.

\subsection{Uniform distribution}
\label{sub:Uniform distribution}

The class template,
\begin{verbatim}
template <typename IntType = int>
class UniformIntDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  \Prob(X = k;a,b) = \frac{1}{b - a + 1},\qquad
  k \in \{a,\dots,b\},\quad
  a \in \Integer,\quad b \in \{x \in \Integer: x \ge a\}.
\end{equation*}
The specific algorithm used depends on the parameters. If $a = b$, then it
simply returns~$a$. If $b - a + 1 = 2^W$ where~$W$ is the number of bits of
|IntType|, then |UniformBitsDistribution| is used (see section~\ref{sec:Uniform
bits distribution}). If $\max\{\Abs{a}, b\} < 2^{32}$, then it uses the fact
that if~$U$ is a standard uniform random variable, then
\begin{equation*}
  X = \Floor{a + (b - a + 1) U}
\end{equation*}
is uniform on the set $\{a,\dots,b\}$. Otherwise the standard library is used.

\section{Multivariate distribution}
\label{sec:Multivariate distribution}

\subsection{Dirichlet distribution}
\label{sub:Dirichlet distribution}

The class template,
\begin{verbatim}
template <typename RealType = double, size_t Dim = Dynamic>
class DirichletDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x_{1:d};\alpha_{1:d}) =
  \frac{\Gamma\Round[Big]{\sum_{i=1}^d\alpha_i}}{\prod_{i=1}^d\Gamma(\alpha_i)}
  \prod_{i=1}^d x_i^{\alpha_i - 1},\qquad
  \sum_{i=1}^d x_i = 1,\quad
  x_{1:d}\in(0,1)^d,\quad
  \alpha_{1:d}\in(0,\infty)^d.
\end{equation*}
The template parameter |Dim| is the dimension of the distribution. If it is
positive, then the dimension is fixed. The distribution generator can be
constructed by,
\begin{verbatim}
DirichletDistribution<double, Dim> dirichlet(alpha);
\end{verbatim}
and if it is zero (recall that |Dynamic| is just an enumerator with value
zero), then the dimension has to be specified at runtime. The distribution
generator can be constructed by,
\begin{verbatim}
DirichletDistribution<double> dirichlet(dim, alpha);
\end{verbatim}
The parameter |alpha| can be either a pointer to a $d$-vector or a scalar. If
it is a scalar, say $\alpha$, then $\alpha_i = \alpha$ for $i = 1,\dots,d$. To
generate one random variate,
\begin{verbatim}
dirichlet(rng, r);
rand(rng, dirichlet, r);
\end{verbatim}
where the output parameter |r| is a pointer to a $d$-vector. Vectorized
generating is also possible,
\begin{verbatim}
dirichlet(rng, n, r);
rand(rng, dirichlet, n, r);
\end{verbatim}
where the output parameter |r| is a pointer to an~$n$ by~$d$ matrix of row
major order.

\subsection{Multivariate Normal distribution}
\label{sub:Multivariate Normal distribution}

The class template,
\begin{verbatim}
template <typename RealType = double, size_t Dim = Dynamic>
class NormalMVDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{align*}
  &f(x_{1:d};\mu_{1:d},\Sigma) = \frac{1}{\sqrt{(2\pi)^d\Abs{\Sigma}}}
  \exp\Curly[Big]{-\frac{1}{2}(x_{1:d} -
  \mu_{1:d})^{\transpose}\Sigma^{-1}(x_{1:d} - \mu_{1:d})},\\
  &x_{1:d}\in\Real^d,\quad
  \mu_{1:d}\in\Real^d,\quad
  \Sigma\in
  \{\,\text{positive semi-definite }d\text{ by }d\text{ matrix}\,\}.
\end{align*}
At the time of writing, only |float| and |double| are supported types for the
template parameter |RealType|. The second template parameter |Dim| specify the
dimension of the distribution, $d$. If |Dim| is positive, then the dimension is
fixed. The distribution generator can be constructed by,
\begin{verbatim}
NormalMVDistribution<double, Dim> normal_mv(mean, chol);
\end{verbatim}
Otherwise, if |Dim| is zero, the dimension has to be specified at runtime. The
distribution generator can be constructed by,
\begin{verbatim}
NormalMVDistribution<double> normal_mv(d, mean, chol);
\end{verbatim}
In either case, the parameter |mean| is a pointer to the mean vector of length
$d$, and |chol| is a pointer to the lower triangular of the Cholesky
decomposition of the covariance matrix packed row by row. For those unfamiliar
with matrix storage schemes, this means that, |chol| is a vector of length
$d(d+1)/2$. Let~$L$ be the lower triangular of the Cholesky decomposition, that
is $LL^{\transpose} = \Sigma$, then the vector is
$(L_{1,1},L_{2,1},L_{2,2},\dots,L_{d,d})^{\transpose}$. Further, both |mean|
and |chol| can also be scalars instead of pointers to vectors. If |mean| is a
scalar, say $\mu$, then the mean vector is assumed to be a $d$-vector with all
elements equal to $\mu$. If |chol| is a scalar, say $\sigma$, then it is
assumed that $L = \sigma I_d$ and thus the covariance matrix is $\Sigma =
\sigma^2 I_d$, where $I_d$ is the identity matrix. To generate a single
multivariate Normal random number,
\begin{verbatim}
normal_mv(rng, r);
rand(rng, normal_mv, r);
\end{verbatim}
where the output parameter |r| is a pointer to a $d$-vector. Vectorized
generating is also possible,
\begin{verbatim}
normal_mv(rng, n, r);
rand(rng, normal_mv, n, r);
\end{verbatim}
where the output parameter |r| is a pointer to an~$n$ by~$d$ matrix of row
major order.

\section{Randomness test}
\label{sec:Randomness tests}

\mckl implements a few classical randomness tests in~\cite{Knuth:1997us}. It is
nowhere near as comprehensive as the \testu library~\cite{Lecuyer:2007hv}.
However, they are easier to use with \cpp \rng engines and distributions. All
tests below follows the same interfaces. They have the following operator,
\begin{verbatim}
template <typename RNGType, typename DistributionType>
result_type operator()(RNGType &rng, DistributionType &distribution);
\end{verbatim}
that accepts the \rng engine and distribution as input and returns the value of
the test statistic. They also have two methods that return the values of \pdf
and \cdf of the test statistic under the null hypothesis, respectively,
\begin{verbatim}
double pdf(result_type s) const;
double cdf(result_type s) const;
\end{verbatim}
Last, they have the following method,
\begin{verbatim}
bool pass(double alpha, result_type s) const;
\end{verbatim}
that returns if the test passes at significance level $\alpha$ given the test
statistic.

Most tests are implemented as class templates. There are a few common template
parameters. The first is~$D$, which is the multiplier. Let $U_{1:n}$ be the
sequence of standard uniform random numbers, then $Y_{1:n}$ is the sequence of
random numbers in $\{0,\dots,D - 1\}$ with $Y_i = \Floor{DU_i}$. Tests with the
template parameter~$D$ use the sequence $Y_{1:n}$ and others use the sequence
$U_{1:n}$ (see~\cite[pp.~61]{Knuth:1997us}). Another common template parameter
is~$T$, which is the length of tuples. Some tests operate on the tuples
$X_{1:n}$, $X_i = (U_{iT},\dots,U_{(i+1)T})$.

\subsection{Serial test}
\label{sub:Serial test}

The template,
\begin{verbatim}
template <size_t D, size_t T, bool Overlap>
using SerialTest = internal::SerialTestImpl<D, T, Overlap && 1 < T>;
\end{verbatim}
is an alias to implementations of the serial tests with independent (|Overlap|
is false) or overlapping tuples (|Overlap| is true) as described
by~\cite[pp.~62]{Knuth:1997us} and~\cite[ex.~24, pp.~78]{Knuth:1997us},
respectively. The constructor,
\begin{verbatim}
SerialTest<D, T, Overlap> test(n);
\end{verbatim}
accepts the number of tuples as the argument. The tests generate~$nT$ and~$n$
random numbers, respectively. The equidistribution test using the
$\chi^2$-statistic~\cite[pp.~61]{Knuth:1997us} is a special case of this test
with $T = 1$.

\subsection{Gap test}
\label{sub:Gap test}

The class template,
\begin{verbatim}
template <size_t NTrialMax = std::numeric_limits<size_t>::max()>
class GapTest;
\end{verbatim}
implements the gap test~\cite[pp.~62]{Knuth:1997us}. The constructor,
\begin{verbatim}
GapTest(size_t n, double alpha, double beta);
\end{verbatim}
accepts the number of gaps, the lower and upper bounds of the gap. The gap test
may not terminate given a deficient sequence. The template parameter
|NTrialMax| is the maximum number of random numbers to be generated for one
gap.

\subsection{Poker test}
\label{sub:Poker test}

The class template,
\begin{verbatim}
template <size_t D, size_t T>
class PokerTest;
\end{verbatim}
implements the (simplified) poker test~\cite[pp.~63]{Knuth:1997us}. The
constructor,
\begin{verbatim}
PokerTest(size_t n);
\end{verbatim}
accepts the number of tuples.

\subsection{Coupon collector's test}
\label{sub:Coupon collector's test}

The class template,
\begin{verbatim}
template <size_t D, size_t NTrialMax = std::numeric_limits<size_t>::max()>
class CouponCollectorTest;
\end{verbatim}
implements the coupon collector's test~\cite[pp.~64]{Knuth:1997us}. The
constructor,
\begin{verbatim}
CouponCollectorTest(size_t n);
\end{verbatim}
accepts the number of tuples. Similar to the gap test, the test may not
terminate given a deficient sequence. The template parameter |NTrialMax| is the
maximum number of trials to generate one complete set.

\subsection{Permutation test}
\label{sub:Permutation test}

The class template,
\begin{verbatim}
template <size_t T>
class PermutationTest;
\end{verbatim}
implements the permutation test~\cite[pp.~65]{Knuth:1997us}. The constructor,
\begin{verbatim}
PermutationTest(size_t n);
\end{verbatim}
accepts the number of tuples.

\subsection{Run test}
\label{sub:Run test}

The templates,
\begin{verbatim}
template <bool Indepenent, bool Up = true>
using RunTest = internal::RunTestImpl<Independent, Up>;
\end{verbatim}
is an alias to implementations of the run tests with dependent or independent
tuples as described by~\cite[pp.~66]{Knuth:1997us} and~\cite[ex.~14,
pp.~77]{Knuth:1997us}, respectively. The constructors,
\begin{verbatim}
RunTest<Independent, Up> test(n);
\end{verbatim}
accept the number of samples and number runs, respectively. The independent
test will generate~$n$ random numbers. The dependent test will always
terminate, but may take a very long time if the sequence is deficient.

\subsection{Maximum-of-\texorpdfstring{$t$}{t} test}
\label{Maximum-of-t test}

The class template,
\begin{verbatim}
template <size_t D, size_t T>
class MaximumOfTTest;
\end{verbatim}
implements the maximum-of-$t$ test~\cite[pp.~70]{Knuth:1997us}. The test is
based on the euquidistribution test using the $\chi^2$-statistic with~$D$
categories~\cite[pp.~61]{Knuth:1997us}. The constructor,
\begin{verbatim}
MaximumOfTTest(size_t n);
\end{verbatim}
accepts the number of tuples.

\subsection{Collision test}
\label{Collision test}

The class template,
\begin{verbatim}
template <size_t D, size_t T>
class CollisionTest;
\end{verbatim}
implements the collision test~\cite[pp.~70]{Knuth:1997us}. The constructor,
\begin{verbatim}
Collision(size_t n);
\end{verbatim}
accepts the number of tuples. The implementation is simplified by using the
asymptotic distribution of the number of collisions, a Poisson distribution
with mean,
\begin{equation*}
  \lambda = k\Round[Big]{
    \frac{n}{k} - 1 + \Round[Big]{1 - \frac{1}{k}}^n},\qquad k = D^T.
\end{equation*}
This is valid when both~$n$ and~$k$ are large and are of the same order or
$n \ll k$.

\subsection{Birthday spacings test}
\label{sub:Birthday spacings test}

The class templates,
\begin{verbatim}
template <size_t D, size_t T>
class BirthdaySpacingsTest;
\end{verbatim}
implements the birthday spacings test~\cite[pp.~71]{Knuth:1997us}. The
constructor,
\begin{verbatim}
BirthdaySpacingsTest(size_t n);
\end{verbatim}
accepts the number of tuples. It uses approximate a Poisson distribution with
mean, $\lambda = n^3/4k$, $k = D^T$. This test is only useful when $\lambda$ is
not too big and~$n$ and~$k$ are large.
