% ============================================================================
%  MCKL/manual/tex/random.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2016, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Random number generating}
\label{chap:Random number generating}

\mckl has a comprehensive \rng system for implementing Monte Carlo algorithms.
Similar to the standard library header |<random>|, there are mainly two parts
of this system. The first is a set of \rng{} engines that generate random
integers. The other is a set of distribution generators. The former are
documented in Sections~\ref{sec:Counter-based RNG} to~\ref{sec:MKL RNG}, and
the later in Section~\ref{sec:Distribution}. There are also some performance
data in Appendices~\appref{chap:Performance of RNG}
and~\appref{chap:Performance of distribution} for them. Apart from these, the
library also provides facilities for vectorized random number generating
(Section~\ref{sec:Vectorized random number generating}) and using multiple
\rng{}s in parallel programs (Section~\ref{sec:Multiple RNG streams}). Last, in
Section~\ref{sec:Randomness tests}, a few randomness tests are discussed.

\section{Vectorized random number generating}
\label{sec:Vectorized random number generating}

The generic function |rand| provides vectorized random number generating. There
are two main variants. The first operates on \rng engines and generates random
integers,
\begin{Verbatim}
template <typename RNGType>
void rand(RNGType &rng, size_t n, typename RNGType::result_type *r);
\end{Verbatim}
The effect of the function call,
\begin{Verbatim}
rand(rng, n, r);
\end{Verbatim}
is equivalent to the loop,
\begin{Verbatim}
for (size_t i = 0; i != n; ++i)
    r[i] = rng();
\end{Verbatim}
The results will always be the same unless a non-deterministic \rng is used
(see Section~\ref{sec:Non-deterministic RNG}). For some \rng{}s implemented in
\mckl, the vectorized function may have considerable performance advantage. The
second variant of |rand| is for generating distribution random variates,
\begin{Verbatim}
template <typename RNGType, typename DistributionType>
void rand(
    RNGType &rng,
    const DistributionType &distribution,
    size_t n,
    typename DistributionType::result_type *r);
\end{Verbatim}
For example,
\begin{Verbatim}
NormalDistribution<double> normal;
rand(rng, normal, n, r);
\end{Verbatim}
This is similar to the following loop,
\begin{Verbatim}
for (size_t i = 0; i != n; ++i)
    r[i] = normal(rng);
\end{Verbatim}
Depending on the type of |rng| and the distribution (including its parameters),
the vectorized function may have superior performance. However, the results
will not be exactly the same as using a loop, except for uniform distributions
(Section~\ref{sub:Uniform bits distribution} and~\ref{sub:Standard uniform
distribution}), which will produce the exactly the same results.

For consistency, \mckl also defines variants of the function |rand| for
generating only one random number,
\begin{Verbatim}
rand(rng);               // => rng();
rand(rng, distribution); // => distribution(rng);
\end{Verbatim}
And each \rng engine and distribution generator also has methods for vectorized
generating,
\begin{Verbatim}
rng(n, r);               // => rand(rng, n, r);
distribution(rng, n, r); // => rand(rng, distribution, n, r);
\end{Verbatim}
To write generic functions, it is recommended to use the function |rand|
instead of the member methods, since the former also works with classes not
defined by \mckl, such as those in the standard library.

\section{Counter-based \texorpdfstring{\protect\rng}{RNG}}
\label{sec:Counter-based RNG}

The standard library provides a set of \rng engines. Unfortunately, none of
them are suitable for parallel computing without considerable efforts. The
development by~\cite{Salmon:2011um} made high performance parallel \rng much
more accessible. The \rng{}s introduced in the paper use bijection $f_k$, such
that, for a sequence $\{c_i = i\}_{i\ge0}$, the sequence $\{y_i =
f_k(c_i)\}_{i\ge0}$ appears random. In addition, for $k_1 \ne k_2$, $f_{k_1}$
and $f_{k_2}$ will generate two sequences that appear statistically
independent. Compared to more conventional \rng{}s which use recursions $y_i =
f_k(y_{i - 1})$, these counter-based \rng{}s are much easier to setup in a
parallelized environment. If $c$, the counter, is an unsigned integer with $b$
bits, and $k$, the key, is an unsigned integer with $d$ bits. Then for each
$k$, the \rng has a period $2^b$. And there can be at most $2^d$ independent
streams. Another way is to view this kind of \rng{}s is that, it is one \rng{}
with state $\{c, k\}$ for $0 \le c < 2^b$ and $0 \le k < 2^d$. And thus it has
a period $2^{b + d}$. And the division of the state into counter and key
provides an easy way to setup a large number of sub-streams.

Table~\ref{tab:Counter-based RNG} lists all counter-based \rng{}s implemented
in \mckl, along with the bits of the counter and the key. They all output
32-bit unsigned integers uniform on the set $\{0,\dots,2^{32}-1\}$. For 64-bit
output, a suffix |_64| may be appended to the corresponding \rng engine names.
For example, |Threefry4x64| and |Threefry4x64_64| both generate the same
256-bit random integers internally. The only difference is that |operator()| of
the former returns 32 of those 256 bits each time it is executed, while the
later returns 64 bits.

All \rng{}s in Table~\ref{tab:Counter-based RNG} are actually type aliases.
More generally \mckl defines the following class template as the interface,
\begin{Verbatim}
template <typename ResultType, typename Generator>
class CounterEngine;
\end{Verbatim}
where |ResultType| shall be an unsigned integer type and |Generator| is the
class that actually implements the algorithm. See the reference manual for
details of the generator type. For most users, those implemented in the library
are sufficient. They are introduced in the next few sections. A few
configuration macros of these generators are listed in
Table~\ref{tab:Configuration macros for counter-based RNG} and will be referred
to later.

\begin{table}
  \tbfigures
  \begin{tabularx}{\textwidth}{lRR}
    \toprule
    \rng engine & Counter bits & Key bits \\
    \midrule
    \texttt{AES128x1}, \texttt{ARS128x2}, \texttt{AES128x4}, \texttt{AES128x8}
    & 128 & 128 \\
    \texttt{AES192x1}, \texttt{ARS192x2}, \texttt{AES192x4}, \texttt{AES192x8}
    & 128 & 192 \\
    \texttt{AES256x1}, \texttt{AES256x2}, \texttt{AES256x4}, \texttt{AES256x8}
    & 128 & 256 \\
    \texttt{ARSx1},    \texttt{ARSx2},    \texttt{ARSx4},    \texttt{ARSx8}
    & 128 & 128 \\
    \texttt{Philox2x32}    & 64   & 32   \\
    \texttt{Philox2x64}    & 128  & 64   \\
    \texttt{Philox4x32}    & 128  & 64   \\
    \texttt{Philox4x64}    & 256  & 128  \\
    \texttt{Threefry2x32}  & 64   & 64   \\
    \texttt{Threefry2x64}  & 128  & 128  \\
    \texttt{Threefry4x32}  & 128  & 128  \\
    \texttt{Threefry4x64}  & 256  & 256  \\
    \texttt{Threefry8x64}  & 512  & 512  \\
    \texttt{Threefry16x64} & 1024 & 1024 \\
    \bottomrule
  \end{tabularx}
  \caption{Counter-based \protect\rng}
  \label{tab:Counter-based RNG}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LL}
    \toprule
    Macro & Default \\
    \midrule
    \texttt{MCKL\_AES128\_ROUNDS}           & 10 \\
    \texttt{MCKL\_AES192\_ROUNDS}           & 12 \\
    \texttt{MCKL\_AES256\_ROUNDS}           & 14 \\
    \texttt{MCKL\_ARS\_ROUNDS}              & 5  \\
    \texttt{MCKL\_AESNI\_BLOCKS}            & 8  \\
    \texttt{MCKL\_PHILOX\_ROUNDS}           & 10 \\
    \texttt{MCKL\_PHILOX\_VECTOR\_LENGTH}   & 4  \\
    \texttt{MCKL\_THREEFRY\_ROUNDS}         & 20 \\
    \texttt{MCKL\_THREEFRY\_VECTOR\_LENGTH} & 4  \\
    \bottomrule
  \end{tabularx}
  \caption{Configuration macros for counter-based \protect\rng}
  \label{tab:Configuration macros for counter-based RNG}
\end{table}

\subsection{\texorpdfstring{\protect\aesni}{AES-NI} instructions based
  \texorpdfstring{\protect\rng}{RNG}}
\label{sub:AES-NI instructions based RNG}

The \aesni\footnote{\url{https://en.wikipedia.org/wiki/AES_instruction_set}}
instructions based \rng{}s in~\cite{Salmon:2011um} are implemented in the
following generator,
\begin{Verbatim}
template <typename KeySeqType, size_t Rounds, size_t Blocks>
class AESNIGenerator;
\end{Verbatim}
The corresponding \rng engine is,
\begin{Verbatim}
template <typename ResultType, typename KeySeqType, size_t Rounds, size_t Blocks>
using AESNIEngine =
    CounterEngine<ResultType, AESNIGenerator<KeySeqType, Rounds, Blocks>>;
\end{Verbatim}
where |KeySeqType| is the class used to generate the sequences of round keys.
The parameter |Rounds| is the number of rounds of \aes encryption to be
performed. See the reference manual for details of how to define the key
sequence class. The \aesni encryption instructions have a latency of seven or
eight cycles, while they can be issued at every cycle. Therefore better
performance can be achieved if multiple 128-bit random integers are generated
at the same time. This is specified by the template parameter |Blocks|. Larger
blocks, up to eight, might improve performance. But this is at the cost of
larger state size. Without going into details, there are four types of sequence
of round keys implemented by \mckl,
\begin{Verbatim}
template <size_t Rounds>
using AES128KeySeq = internal::AESKeySeq<Rounds, internal::AES128KeySeqGenerator>;

template <size_t Rounds>
using AES192KeySeq = internal::AESKeySeq<Rounds, internal::AES192KeySeqGenerator>;

template <size_t Rounds>
using AES256KeySeq = internal::AESKeySeq<Rounds, internal::AES256KeySeqGenerator>;

template <typename Constants = ARSConstants>
using ARSKeySeq = internal::ARSKeySeqImpl<Constants>;
\end{Verbatim}
and correspondingly four \rng engines,
\begin{Verbatim}
template <
    typename ResultType,
    size_t Rounds = MCKL_AES128_ROUNDS,
    size_t Blocks = MCKL_AESNI_BLOCKS>
using AES128Engine = AESNIEngine<ResultType, AES128KeySeq<Rounds>, Rounds, Blocks>;

template <
    typename ResultType,
    size_t Rounds = MCKL_AES192_ROUNDS,
    size_t Blocks = MCKL_AESNI_BLOCKS>
using AES192Engine = AESNIEngine<ResultType, AES192KeySeq<Rounds>, Rounds, Blocks>;

template <
    typename ResultType,
    size_t Rounds = MCKL_AES256_ROUNDS,
    size_t Blocks = MCKL_AESNI_BLOCKS>
using AES256Engine = AESNIEngine<ResultType, AES256KeySeq<Rounds>, Rounds, Blocks>;

template <
    typename ResultType,
    size_t Rounds = MCKL_ARS_ROUNDS,
    size_t Blocks = MCKL_AESNI_BLOCKS,
    typename Constants = ARSConstants>
using ARSEngine = AESNIEngine<ResultType, ARSKeySeq<Constants>, Rounds, Blocks>;
\end{Verbatim}
The first three are equivalent to \aes-128, \aes-192 and \aes-256 block ciphers
used in counter mode. The last is the \ars algorithm introduced
by~\cite{Salmon:2011um}. The last template parameter |Constants| of |ARSKeySeq|
and |ARSEngine| is a trait class that defines the constants of the Weyl's
sequence. See~\cite{Salmon:2011um} for details. The defaults are taken from the
paper. To use an alternative pair of 64-bit integers as the constants, one can
define and use a trait class as the following,
\begin{Verbatim}
template <size_t>
struct NewWeylConstant;

template<>
struct NewWeylConstant<0>
{
    static constexpr std::uint64_t value = FIRST_CONSTANT;
};

template<>
struct NewWeylConstant<1>
{
    static constexpr std::uint64_t value = SECOND_CONSTANT;
};

struct NewConstants
{
    template <size_t I>
    using weyl = NewWeylConstant<I>;
};

using NewARS = ARSEngine<ResultType, Rounds, NewConstants>;
\end{Verbatim}
Alternative methods are also possible. The only requirement is that, the
following statement,
\begin{Verbatim}
template <size_t I>
using weyl = typename Constants::template weyl<I>;
\end{Verbatim}
shall define the type |weyl| such that it has a static constant expression
member data |value| that is the |I|\ith Weyl constant. A few type aliases are
defined for convenience. For example,
\begin{Verbatim}
using ARSx8    = ARSEngine<std::uint32_t, MCKL_ARS_ROUNDS, 8>;
using ARSx8_64 = ARSEngine<std::uint64_t, MCKL_ARS_ROUNDS, 8>;
using ARS      = ARSEngine<std::uint32_t>;
using ARS_64   = ARSEngine<std::uint64_t>;
\end{Verbatim}
The engine |ARS| is the default \rng if \aesni instructions are supported.
Aliases for block sizes 1, 2, 4 and 8 are defined for all four algorithms, as
well as both 32- and 64-bit output variants. These aliases are listed in
Table~\ref{tab:Counter-based RNG}. The performance of these engines depends on
a few factors, such as \cpu types, compilers, operating systems, etc. In any
case, the performance is good enough even for the most demanding applications.
\mckl does not attempt to optimize the algorithm for any particular platform.
In realistic applications, the performance of \rng is unlikely to become a
bottle neck. Note that, the best performance is obtained with the vectorized
|rand| function (see Section~\ref{sec:Vectorized random number generating}).

\subsection{Philox}
\label{sub:Philox}

The Philox algorithm in~\cite{Salmon:2011um} is implemented in the following
generator,
\begin{Verbatim}
template <
    typename T,
    size_t K = MCKL_PHILOX_VECTOR_LENGTH,
    size_t Rounds = MCKL_PHILOX_ROUNDS,
    typename Constants = PhiloxConstants<T, K>>
class PhiloxGenerator;
\end{Verbatim}
The corresponding \rng engine is,
\begin{Verbatim}
template <
    typename ResultType,
    typename T = ResultType,
    size_t K = MCKL_PHILOX_VECTOR_LENGTH,
    size_t Rounds = MCKL_PHILOX_ROUNDS,
    typename Constants = PhiloxConstants<T, K>>
using PhiloxEngine =
    CounterEngine<ResultType, PhiloxGenerator<T, K, Rounds, Constants>>;
\end{Verbatim}
The default vector length and the number of rounds can be changed by
configuration macros listed in Table~\ref{tab:Configuration macros for
counter-based RNG}. There is no limit on the template parameter |K| or
|Rounds|, nor any limitation on |T| except that it has to be an unsigned
integer type. See~\cite{Salmon:2011um} on the most general form of the
algorithm. However, \mckl only provides default constants for 32- and 64-bit
unsigned integer type |T| and |K| taking the values~2 or~4. These four engines
are defined as type aliases for convenience,
\begin{Verbatim}
template <typename ResultType>
using Philox2x32Engine = PhiloxEngine<ResultType, std::uint32_t, 2>;

template <typename ResultType>
using Philox4x32Engine = PhiloxEngine<ResultType, std::uint32_t, 4>;

template <typename ResultType>
using Philox2x64Engine = PhiloxEngine<ResultType, std::uint64_t, 2>;

template <typename ResultType>
using Philox4x64Engine = PhiloxEngine<ResultType, std::uint64_t, 4>;
\end{Verbatim}
Type aliases for 32- and 64-bit |ResultType| are also defined, as listed in
Table~\ref{tab:Counter-based RNG}. To use the engine with |K| taking values
larger than four, or |T| being unsigned integer type with number of bits other
than 32 or 64, one needs to provide a suitable trait class, |Constant|. It is
similar to that of |ARSEngine|. See the reference manual of |PhiloxConstants|
for an example of how to define it.

\subsection{Threefry}
\label{sub:Threefry}

The Threefry algorithm in~\cite{Salmon:2011um} is implemented in the following
generator,
\begin{Verbatim}
template <
    typename T,
    size_t K = MCKL_THREEFRY_VECTOR_LENGTH,
    size_t Rounds = MCKL_THREEFRY_ROUNDS,
    typename Constants = ThreefryConstants<T, K>>
class ThreefryGenerator;
\end{Verbatim}
The corresponding \rng engine is,
\begin{Verbatim}
template <
    typename ResultType,
    typename T = ResultType,
    size_t K = MCKL_THREEFRY_VECTOR_LENGTH,
    size_t Rounds = MCKL_THREEFRY_ROUNDS,
    typename Constants = ThreefryConstants<T, K>>
using ThreefryEngine =
    CounterEngine<ResultType, ThreefryGenerator<T, K, Rounds, Constants>>;
\end{Verbatim}
The default vector length and the number of rounds can be changed by
configuration macros listed in Table~\ref{tab:Configuration macros for
counter-based RNG}. Similar to the implementation of the Philox algorithm,
there is no limit on the template parameter |K| or |Rounds| as long as a
suitable trait class |Constant| is provided. \mckl provides default constants
for 64-bit unsigned integer type |T| and |K| taking the values 4, 8 and~16,
taken from the skein\footnote{\url{http://www.skein-hash.info}} hash algorithm,
for which the Threefish algorithm was originally developed for. Defaults for
32-bit |T| or |K| taking the value~2 are also provided, taken
from~\cite{Salmon:2011um}. Type aliases for these configurations are defined
for convenience, Type aliases for 32- and 64-bit |ResultType| are also defined,
as listed in Table~\ref{tab:Counter-based RNG}.
\begin{Verbatim}
template <typename ResultType>
using Threefry2x32Engine = ThreefryEngine<ResultType, std::uint32_t, 2>;

template <typename ResultType>
using Threefry4x32Engine = ThreefryEngine<ResultType, std::uint32_t, 4>;

template <typename ResultType>
using Threefry2x64Engine = ThreefryEngine<ResultType, std::uint64_t, 2>;

template <typename ResultType>
using Threefry4x64Engine = ThreefryEngine<ResultType, std::uint64_t, 4>;

template <typename ResultType>
using Threefry8x64Engine = ThreefryEngine<ResultType, std::uint64_t, 8>;

template <typename ResultType>
using Threefry16x64Engine = ThreefryEngine<ResultType, std::uint64_t, 16>;
\end{Verbatim}

\subsection{Seeding counter-based \texorpdfstring{\protect\rng}{RNG}}
\label{sub:Seeding counter-based RNG}

The singleton class template |SeedGenerator| can be used to generate
distinctive seeds sequentially. For example,
\begin{Verbatim}
auto &seed = SeedGenerator<void, unsigned>::instance();
RNG rng1(seed.get()); // Construct rng1
RNG rng2(seed.get()); // Construct rng2 with another seed
\end{Verbatim}
The first argument to the template can be any type. For different types,
different instances of |SeedGenerator| will be created. Thus, the seeds
generated by two generators, |SeedGenerator<T1>| and |SeedGenerator<T2>|, will
be independent. The second parameter is the type of the seed values. It can be
any unsigned integer type. Classes such as |Particle<T>| will use the generator
of the following type,
\begin{Verbatim}
using Seed = SeedGenerator<NullType, MCKL_SEED_RESULT_TYPE>;
\end{Verbatim}
where |MCKL_SEED_RESULT_TYPE| is a configuration macro which is defined to
|unsigned| by default.

One can save and set the seed generator using standard streams. For example,
\begin{Verbatim}
std::ifstream is("seed.txt");
if (is)
    is >> Seed::instance();    // Read seed from a file
else
    Seed::instance().set(101); // Set it manually
is.close();
// Using Seed
std::ofstream os("seed.txt");
os << Seed::instance();        // Write the seed to a file
os.close();
\end{Verbatim}
This way, if the simulation program needs to be repeated multiple times, each
time it will use a different set of seeds. A single seed generator is enough
for a single program. However, it is more difficult to ensure that each
computing node has a distinctive set of seeds in a distributed system. A simple
solution is to use the |modulo| method of |SeedGenerator|. For example,
\begin{Verbatim}
Seed::instance().modulo(n, r);
\end{Verbatim}
where $n$ is the number of processes and $r$ is the rank of the current node.
After this call, all seeds generated will belong to the equivalent class $s
\equiv r \mod n$. Therefore, no two nodes will ever generate the same seeds.
Note that, the seeds generated are not random at all. For any deterministic
\rng{}s, the same seeds always produce identical streams. However, distinctive
seeds does not always lead to independent streams. This seed generator is only
suitable for counter-based \rng{}s.

\section{Non-deterministic \texorpdfstring{\protect\rng}{RNG}}
\label{sec:Non-deterministic RNG}

If the \rdrand instructions are supported, \mckl also implements three
non-deterministic \rng{}s, |RDRAND16|, |RDRAND32| and |RDRAND64|. They output
16-, 32-, and 64-bit random integers, respectively. The \rdrand instruction may
not return a random integer at all. The \rng engine will keep trying until it
succeeds. One can limit the maximum number of trials by defining the
configuration macro |MCKL_RDRAND_NTRIAL_MAX|. A value of zero, the default,
means the number of trials is unlimited. If it is a positive number, and if
after the specified number of trials no random integer is return by the \rdrand
instruction, zero is returned.

\section{\texorpdfstring{\protect\rng{} \protect\rng}{MKL RNG}}
\label{sec:MKL RNG}

The \mkl library provides some high performance \rng{}s. \mckl implements a
wrapper class |MKLEngine| that makes them accessible as \cpp engines. They are
listed in Table~\ref{tab:MKL RNG}. Note that, \mkl{} \rng{}s perform the best
when they are used to generate vectors of random numbers. These wrappers use a
buffer to store such vectors. And thus they have much larger state space than
usual \rng{}s. Each \rng engines output by default 32-bit integers. Similar to
the counter-based \rng{}s, 64-bit variants are also defined.

When there are \mkl routines for generating distribution random variates for
one of the distributions discussed later in Section~\ref{sec:Distribution}, the
library will automatically use \mkl routines for vectorized random number
generating if the \rng{} is one of that listed in Table~\ref{tab:MKL RNG}. For
example,
\begin{Verbatim}
MKL_SFMT19937 rng;
NormalDistribution<double> normal;
normal(rng, n, r);       // Use MKL
rand(rng, normal, n, r); // Use MKL
\end{Verbatim}
Note that, this is only applicable when the distribution is a class in this
library. It will not work with classes such as |std::normal_distribution|. This
is also applicable when the distribution is not directly supported by \mkl, but
can be easily generated using other distributions, e.g., the Student's
$t$-distribution. In addition, it is also applicable if a distribution is a
special case of one of the distributions supported by \mkl.

\begin{table}
  \begin{tabularx}{\textwidth}{LL}
    \toprule
    \rng engine & \mkl{} \brng \\
    \midrule
    \texttt{MKL\_MCG59}         & \texttt{VSL\_BRNG\_MCG59}         \\
    \texttt{MKL\_MT19937}       & \texttt{VSL\_BRNG\_MT19937}       \\
    \texttt{MKL\_MT2203}        & \texttt{VSL\_BRNG\_MT2203}        \\
    \texttt{MKL\_SFMT19937}     & \texttt{VSL\_BRNG\_SFMT19937}     \\
    \texttt{MKL\_NONDETERM}     & \texttt{VSL\_BRNG\_NONDETERM}     \\
    \texttt{MKL\_ARS5}          & \texttt{VSL\_BRNG\_ARS5}          \\
    \texttt{MKL\_PHILOX4X32X10} & \texttt{VSL\_BRNG\_PHILOX4X32X10} \\
    \bottomrule
  \end{tabularx}
  \caption{\protect\mkl{} \protect\rng}
  \label{tab:MKL RNG}
\end{table}

\section{Multiple \texorpdfstring{\protect\rng}{RNG} streams}
\label{sec:Multiple RNG streams}

Earlier in Section~\ref{sec:Particle} we introduced that |particle.rng(i)|
returns an independent \rng instance. This is actually done through a class
template called |RNGSet|. Three of them are implemented in \mckl. They all have
the same interface,
\begin{Verbatim}
RNGSet<RNG> rng_set(N); // A set of N RNGs
rng_set.resize(n);      // Change the size of the set
rng_set[i];             // Get a reference to the i-th RNG
rng_set.seed();         // Seed each RNG in the set with Seed::instance()
\end{Verbatim}
The first implementation is |RNGSetScalar|. As its name suggests, it is only a
wrapper of a single \rng. All calls to |rng_set[i]| returns a reference to the
same \rng. It is only useful when an |RNGSet| interface is required while the
thread-safety and other issues are not important.

The second implementation is |RNGSetVector|. It is an array of \rng{}s with
length $N$. It has memory cost $O(N)$. Many of the counter-based \rng{}s have
small state size and thus for moderate $N$, this cost is not an issue. The
method calls |rng_set[i]| and |rng_set[j]| return independent \rng{}s if $i \ne
j$. This implementation has the advantage that the behavior of an algorithm can
be entirely deterministic even when the scheduling of parallel execution is
dynamic, since each sample has its own \rng.

Last, if \tbb is available, there is a third implementation |RNGSetTBB|, which
uses thread-local storage (\tls). It has much smaller memory footprint than
|RNGSetVector| while maintains better thread-safety. The performance impact of
using \tls is minimal unless the computation at the calling site is trivial.
For example,
\begin{Verbatim}
void eval_each(size_t, ParticleIndex<T> idx)
{
    auto &rng = idx.rng();
    // using rng to initialize state
    // do some computation, likely far more costly than TLS
}
\end{Verbatim}
The type alias |RNGSet| is defined to be |RNGSetTBB| if \tbb is available,
otherwise defined to be |RNGSetVector|. It is used by the |Particle| class
template. One can replace the type of \rng set used by |Particle<T>| with a
member type of |T|. For example,
\begin{Verbatim}
class T
{
    public:
    using rng_set_type = RNGSetScalar<RNG>;
};
\end{Verbatim}
will replace the type of the \rng set contained in |Particle<T>|. One can also
define their own replacement type, as long as it has the same interface as the
builtin ones.

\section{Distribution}
\label{sec:Distribution}

\mckl provides implementations of some common distributions. Some of them are
the same as those in the standard library with |CamelCase| names. For example,
|NormalDistribution| can be used in place of |std::normal_distribution|. This
includes all of the continuous distributions in the standard library. As stated
in Section~\ref{sec:Vectorized random number generating}, all the distributions
defined in \mckl support vectorized random number generating. In the following
sections, we introduce each of them. Section~\ref{sub:Uniform bits
distribution} discusses the uniform bits distribution, which is actually a low
level distribution indirectly used by all other distributions.
Section~\ref{sub:Standard uniform distribution} shows few different standard
uniform distributions. And in Sections~\ref{sub:Continuous distributions}
and~\ref{sub:Discrete distributions} we list continuous and discrete
distributions, respectively. In these two sections, the \pdf or \pmf and class
declaration of each distribution are shown first, and then we briefly discuss
the algorithm used for implementation. Last, in Section~\ref{sub:Multivariate
distributions} we briefly discusses a few multivariate distributions
implemented in \mckl.

\subsection{Uniform bits distribution}
\label{sub:Uniform bits distribution}

The class template,
\begin{Verbatim}
template <typename UIntType>
class UniformBitsDistribution;
\end{Verbatim}
is similar to the standard library's |std::independent_bits_engine|, except
that it always generates full size random integers and |UIntType| must have
size at least of that of |short|. That is, let $W$ be the number of bits of
|UIntType|, then the output is uniform on the set $\{0,\dots,2^W - 1\}$. For
example,
\begin{Verbatim}
UniformBitsDistribution<std::uint32_t> ubits;
ubits(rng); // Return 32-bit random integers
\end{Verbatim}
Let $\rmin$ and $\rmax$ be the minimum and maximum of the random integers
generated by |rng|. Let $R = \rmax - \rmin + 1$. Let $r_i$ be consecutive
output of |rng()|. If there exists an integer $V > 0$ such that $R = 2^V$, then
the result is,
\begin{equation*}
  U = \sum_{k = 0}^{K - 1} (r_k - \rmin) 2^{kV} \bmod 2^W
\end{equation*}
where $K = \Ceil{W / V}$. Unlike |std::independent_bits_engine|, the
calculation can be vectorized, which leads to better performance. Note that,
all constants in the algorithm are computed at compile-time and the summation
is fully unrolled. There is no runtime overhead. In the case $\rmin = 0$ and $V
= W$, most optimizing compilers shall be able to generate instructions such
that the distribution does exactly nothing and returns the results of |rng()|
directly. If there does not exist an integer $V > 0$ such that $R = 2^V$, then
|std::indepdent_bits_engine| will be used.

\subsection{Standard uniform distribution}
\label{sub:Standard uniform distribution}

\mckl provides five standard uniform distributions. They are all class
templates with a single template type parameter |RealType|. The random integers
produced by \rng{}s are transferred to 32- or 64-bit random integers through
the class |UniformBitsDistribution| before they are mapped to floating point
numbers within the interval $[0, 1]$. The integer type depends on |RealType|,
the range of the \rng{}, $R$, and |MCKL_U01_USE_64BITS_DOUBLE|, a configuration
macro. The exact relations are listed in Table~\ref{tab:Intermediate integer
types of uniform distributions}. In the following, let $W$ be the number of
bits of the integer type, and $M$ be the number of significant bits (including
the implicit one) of |RealType|. We also denote the input random integers as
$U$ and the output random real numbers as $X$.

\begin{table}
  \begin{tabularx}{\textwidth}{LlL}
    \toprule
    \texttt{RealType} & Conditions & Integer type \\
    \midrule
    \texttt{float}  & $\log_2 R \ge 64$ & \texttt{std::uint64\_t} \\
                    & Otherwise         & \texttt{std::uint32\_t} \\
    \texttt{double} & $\log_2 R \ge 64$ & \texttt{std::uint64\_t} \\
    & \texttt{MCKL\_U01\_USE\_64BITS\_DOUBLE} & \texttt{std::uint64\_t} \\
    & Otherwise & \texttt{std::uint32\_t} \\
    \texttt{long double} & Always & \texttt{std::uint64\_t} \\
    \bottomrule
  \end{tabularx}
  \caption{Intermediate integer types of uniform distributions}
  \label{tab:Intermediate integer types of uniform distributions}
\end{table}

\subsubsection{Standard form}

The class template,
\begin{Verbatim}
template <typename RealType = double>
class U01Distribution;
\end{Verbatim}
implements the uniform distribution on $[0, 1)$. If |MCKL_U01_USE_FIXED_POINT|
is true, which is the default, then it is an alias to |U01CODistribution| (see
below). Otherwise, it is implemented through the mapping,
\begin{align*}
  P &= \Floor{(W + M - 1) / W} \\
  K &= \max\{1, P\} \\
  X &= \sum_{k=0}^{K - 1} U_k 2^{-(K - k)W}
\end{align*}

\subsubsection{Closed-closed interval}

The class template,
\begin{Verbatim}
template <typename RealType = double>
class U01CCDistribution;
\end{Verbatim}
implements the uniform distribution on $[0, 1]$ through the mapping,
\begin{align*}
  P &= \min\{W - 1, M\} \\
  V &= \begin{cases}
    U &\text{if } P + 1 < W \\
    \Floor{(U \bmod 2^{W - 1}) / 2^{W - P -2}} &\text{otherwise}
  \end{cases} \\
  Z &= (V \bmod 2) + V \\
  X &= 2^{-(P + 1)} Z
\end{align*}
The minimum and maximum are $0$ and $1$, respectively.

\subsubsection{Closed-open interval}

The class template,
\begin{Verbatim}
template <typename RealType = double>
class U01CODistribution;
\end{Verbatim}
implements the uniform distribution on $[0, 1)$ through the mapping,
\begin{align*}
  P &= \min\{W, M\} \\
  V &= \Floor{U / 2^{W - P}} \\
  X &= 2^{-P} V
\end{align*}
The minimum and maximum are $0$ and $1 - 2^{-P}$, respectively.

\subsubsection{Open-closed interval}

The class template,
\begin{Verbatim}
template <typename RealType = double>
class U01OCDistribution;
\end{Verbatim}
implements the uniform distribution on $(0, 1]$ through the mapping,
\begin{align*}
  P &= \min\{W, M\} \\
  V &= \Floor{U / 2^{W - P}} \\
  X &= 2^{-P} V + 2^{-P}
\end{align*}
The minimum and maximum are $2^{-P}$ and $1$, respectively.

\subsubsection{Open-open interval}

The class template,
\begin{Verbatim}
template <typename RealType = double>
class U01CODistribution;
\end{Verbatim}
implements the uniform distribution on $(0, 1)$ through the mapping,
\begin{align*}
  P &= \min\{W + 1, M\} \\
  V &= \Floor{U / 2^{W + 1 - P}} \\
  X &= 2^{-(P - 1)} V + 2^{-P}
\end{align*}
The minimum and maximum are $2^{-P}$ and $1 - 2^{-P}$, respectively.

\subsubsection{Performance and accuracy considerations}

The last four distributions actually produce ``fixed point'' numbers. The
output $X$ can be represented exactly by the target |RealType|. They have two
advantages. First, when it is important that the lower or upper bound is never
produced, to avoid underflow, overflow or other undefined behaviors in
subsequent calculations, they provide such assurance. The implementation of the
other distributions discussed later rely on these behaviors to avoid producing
infinite numbers. Second, they usually can be executed with only a couple of
instructions by modern processors. And thus can have better performance.

The main drawback is accuracy. If |RealType| is |float| or |long double|, then
the difference is minimal, since the random integers have more bits than the
significant of the target floating point types. The situation is a bit more
tricky when the output type is |double| and the integer type has only 32 bits.
In this case, |U01CODistribution|, etc., can only produce $2^{32}$ distinctive
values while |double| can represent much more values exactly within the range
$[0, 1]$. In contrast, the standard library will use at least 53 random bits.
This will not matter in many realistic applications. In fact, random numbers
produced by |U01CODistribution|, etc., passes all tests in the \testu
library~\cite{Lecuyer:2007hv} that |std::uniform_real_distribution| would pass,
for a good \rng. In other words, the quality of the \rng is the dominating
factor.

However, there are situations where one does want the extra precision. In this
case, one can define |MCKL_U01_USE_64BITS_DOUBLE| to a non-zero value, such
that the random integers will always be 64-bit for |double| output.

\subsection{Continuous distributions}
\label{sub:Continuous distributions}

All continuous distributions support all three types of floating point numbers,
unless stated otherwise.

\subsubsection{Arcsine distribution}

\begin{equation*}
  f(x;\alpha,\beta) = \frac{1}{\pi\sqrt{(x - \alpha)(\beta - x)}} \qquad
  x \in [a, b],\quad a \in (0,\infty),\quad b \in (0,\infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class ArcsineDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Beta distribution}

\begin{equation*}
  f(x;\alpha,\beta) =
  \frac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)}
  x^{\alpha - 1}(1 - x)^{\beta - 1} \qquad
  x \in (0, 1),\quad \alpha \in (0,\infty),\quad \beta \in (0,\infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class BetaDistribution;
\end{Verbatim}
The specific algorithm used depends on the parameters. If $\alpha = 1/2$ and
$\beta = 1/2$, or $\alpha = 1$ or $\beta = 1$, then the inverse method is used.
If $\alpha > 1$ and $\beta > 1$, the method in~\cite{Cheng:1978jl} is used.
Otherwise, let $K = 0.852$, $C = -0.956$, and $D = \beta + K\alpha^2 + C$. If
$\alpha < 1$, $\beta < 1$ and $D \le 0$, then JÃ¶hnk's
method~\cite[sec.~3.5]{Devroye:1986gi} is used. In all other cases, one of the
switching algorithms in~\cite{Atkinson:1979es} is used. Note that, there is no
vectorized implementation at the moment for the switching algorithms. In other
cases, the vectorized generating shall provide considerable speedup.

\subsubsection{Cauchy distribution}

\begin{equation*}
  f(x;a,b) =
  \frac{1}{\pi b\Round[Big]{1 + \Round[Big]{\frac{x - a}{b}}^2}} \qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0,\infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class CauchyDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{\texorpdfstring{$\chi^2$}{Chi-squared}-distribution}

\begin{equation*}
  f(x;n) = \frac{x^{n/2 - 1}\EE^{-x/2}}{2^{n/2}\Gamma(n/2)} \qquad
  x \in (0,\infty),\quad n \in (0,\infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class ChiSquaredDistribution;
\end{Verbatim}
The implementation uses the fact that if $X$ is a Gamma random variable with
shape $n / 2$ and scale $2$, then $X$ is also $\chi^2$-distributed. See below
for the implementation of the Gamma distribution.

\subsubsection{Exponential distribution}

\begin{equation*}
  f(x;\lambda) = \lambda\EE^{-\lambda x} \qquad
  x \in [0,\infty),\quad \lambda \in (0,\infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class ExponentialDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Extreme value distribution}

\begin{equation*}
  f(x;a,b) =
  \frac{1}{b}\exp\Curly[Big]{
    \frac{a - x}{b} - \exp\Curly[Big]{\frac{a - x}{b}}} \qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0, \infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class ExtremeValueDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Fisher's \texorpdfstring{$F$}{F}-distribution}

\begin{align*}
  & f(x;m,n) =
  \frac{\Gamma\Round[Big]{\frac{m + n}{2}}}{
    \Gamma\Round[Big]{\frac{m}{2}}\Gamma\Round[Big]{\frac{n}{2}}}
  \Round[Big]{\frac{m}{n}}^{m/2} x^{m / 2 - 1}
  \Round[Big]{1 + \frac{m}{n}x}^{-(m + n) / 2} \\
  & x \in [0, \infty),\quad m \in (0, \infty),\quad n \in (0, \infty)
\end{align*}
\begin{Verbatim}
template <typename RealType = double>
class FisherFDistribution;
\end{Verbatim}
The implementation uses the fact that if $U$ and $V$ are $\chi^2$-distributed
random variables with degrees of freedom $m$ and $n$, respectively, and they
are independent, then
\begin{equation*}
  X = \frac{U / V}{m / n}
\end{equation*}
is a Fisher's $F$-distributed random variable with the respective degrees of
freedom. See above for the implementation of the $\chi^2$-distribution.

\subsubsection{Gamma distribution}

\begin{equation*}
  f(x;\alpha,\beta) =
  \frac{\EE^{-x/\beta}}{\Gamma(\alpha)}\beta^{-\alpha}x^{\alpha-1} \qquad
  x \in (0, \infty),\quad \alpha \in (0, \infty),\quad \beta \in (0, \infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class GammaDistribution;
\end{Verbatim}
The specific algorithm used depends on the parameters. If $\alpha = 1$, it
becomes the exponential distribution. If $0 < \alpha < 0.6$, it is generated
through transformation of exponential power
distribution~\cite[sec~2.6]{Devroye:1986gi}. If $0.6\le\alpha<1$, then
rejection method from the Weibull distribution is
used~\cite[sec.~3.4]{Devroye:1986gi}. If $\alpha > 1$, then the method
in~\cite{Marsaglia:2000vq} is used.

\subsubsection{Laplace distribution}

\begin{equation*}
  f(x;a,b) = \frac{1}{2b}\exp\Curly[Big]{-\frac{\Abs{x - a}}{b}} \qquad
  x \in \Real,\quad b \in (0, \infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class LaplaceDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Levy distribution}

\begin{equation*}
  f(x;a,b) =
  \sqrt{\frac{b}{2\pi}}
  \frac{\exp\Curly[Big]{-\frac{b}{2(x - a)}}}{(x - a)^{3/2}} \qquad
  x \in [a, \infty),\quad a \in \Real,\quad b \in (0, \infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class LevyDistribution;
\end{Verbatim}
The implementation uses the fact that if $Z$ is a standard Normal random
variable, then
\begin{equation*}
  X = a + b / Z^2
\end{equation*}
is Levy distributed with location $a$ and scale $b$. See below for the
implementation of the Normal distribution.

\subsubsection{Logistic distribution}

\begin{equation*}
  f(x;a,b) = \frac{1}{4b}\mathrm{sech}^2\Round[Big]{\frac{x - a}{2b}} \qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0, \infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class LaplaceDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Log-normal distribution}

\begin{align*}
  & f(x;m,s) =
  \frac{1}{x\sigma\sqrt{2\pi}}
  \exp\Curly[Big]{-\frac{(\ln x - m)^2}{2\sigma^2}} \\
  & x \in (0, \infty),\quad m \in \Real,\quad s \in (0, \infty)
\end{align*}
\begin{Verbatim}
template <typename RealType = double>
class LognormalDistribution;
\end{Verbatim}
The implementation uses the fact that if $Z$ is a standard Normal random
variable, then
\begin{equation*}
  X = \exp\{m + sZ\}
\end{equation*}
is Log-normal distributed with location $m$
and scale $s$. See below for the implementation of the Normal distribution.

\subsubsection{Normal distribution}

\begin{equation*}
  f(x;\mu,\sigma) =
  \frac{1}{\sqrt{2\pi\sigma^2}}
  \exp\Curly[Big]{-\frac{(x-\mu)^2}{2\sigma^2}} \qquad
  x \in \Real,\quad \mu \in \Real,\quad \sigma \in (0, \infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class NormalDistribution;
\end{Verbatim}
The implementation uses the Box-Muller method~\cite{Box:1958hv}.

\subsubsection{Pareto distribution}

\begin{equation*}
  f(x;a,b) = \frac{a b^a}{x^{a + 1}} \qquad
  x \in [b, \infty),\quad a \in [0, \infty),\quad b \in [0, \infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class ParetoDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Rayleigh distribution}

\begin{equation*}
  f(x;\sigma) =
  \frac{x}{\sigma^2}\exp\Curly[Big]{-\frac{x^2}{2\sigma^2}} \qquad
  x \in [0, \infty),\quad \sigma \in (0, \infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class RayleighDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Stable distribution}

\begin{align*}
  &f(x;\alpha,\beta,a,b) =
  \frac{1}{2\pi}\int_{\infty}^{\infty}
  \varphi(t;\alpha,\beta,a,b)\EE^{-ixt}\intd t\\
  &\varphi(t;\alpha,\beta,a,b) =
  \exp\{ita - \Abs{bt}^{\alpha}(1 - i\beta\mathrm{sgn}(t)\Phi(t;\alpha))\} \\
  &\Phi(t;\alpha) = \begin{cases}
    \tan\Round[big]{\frac{\pi}{2}\alpha} & \alpha \ne 1 \\
    -\frac{2}{\pi}\log\Abs{t}            & \alpha = 1
  \end{cases} \\
  & x \in \Real,\quad
  \alpha \in (0, 2],\quad \beta \in [-1, 1],\quad
  a \in \Real,\quad b \in (0, \infty)
\end{align*}
\begin{Verbatim}
template <typename RealType = double>
class StableDistribution;
\end{Verbatim}
The implementation uses the method in~\cite{Chambers:1976dv}. Note that, some
other distributions implemented in \mckl, such as the Cauchy distribution
($\alpha = 1$, $\beta = 0$), the Levy distribution ($\alpha = 1/2$, $\beta =
1$), and the Normal distribution ($\alpha = 2$), are all special cases of the
stable distribution. It is possible to use implementations of those
distributions to speed up the stable distribution in special cases. However,
\mckl does not do so. Every distribution implemented in \mckl goes through some
basic statistical tests to ensure correctness. Without a tractable distribution
function in general, the stable distribution is somehow more difficult to test
than others. Therefore, we use these special cases to tests the implementation,
which is generic with respect to parameter values. In applications, for
generating random numbers from distributions of those special cases, use the
dedicated classes instead of this one. There are also a few distributions not
implemented by \mckl, but are special cases of the stable distribution, such as
the Landau distribution ($\alpha = 1$, $\beta = 1$) and Holtsmark distribution
($\alpha = 3/2$, $\beta = 0$), to name just two of them.

\subsubsection{Student's \texorpdfstring{$t$}{t}-distribution}

\begin{equation*}
  f(x;n) =
  \frac{\Gamma\Round[Big]{\frac{n + 1}{2}}}
  {\sqrt{n\pi}\Gamma\Round[Big]{\frac{n}{2}}}
  \Round[Big]{1 + \frac{x^2}{n}}^{-(n + 1)/2} \qquad
  x \in \Real,\quad n \in (0, \infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class StudentTDistribution;
\end{Verbatim}
The implementation uses the fact that if $Z$ is a standard Normal random
variable, $V$ is a $\chi^2$-distributed random variable with degree of freedom
$n$, and they are independent, then
\begin{equation*}
  X = \frac{Z}{\sqrt{V / n}}
\end{equation*}
is Student's $t$-distributed with the respective degree of freedom. See above
for the implementations of the Normal distribution and the
$\chi^2$-distribution.

\subsubsection{Uniform distribution}

\begin{equation*}
  f(x;a,b) = \frac{1}{b - a} \qquad
  x \in [a, b),\quad a \in \Real,\quad b \in (a, \infty)
\end{equation*}
\begin{Verbatim}
template <typename RealType = double>
class UniformRealDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsubsection{Weibull distribution}

\begin{align*}
  &f(x;a,b) = \frac{a}{b}\Round[Big]{\frac{x}{b}}^{a - 1}
  \exp\Curly[Big]{-\Round[Big]{\frac{x}{b}}^a} \\
  &x \in [0, \infty),\quad a \in (0, \infty),\quad b \in (0, \infty)
\end{align*}
\begin{Verbatim}
template <typename RealType = double>
class WeibullDistribution;
\end{Verbatim}
The implementation uses the inverse method.

\subsection{Discrete distributions}
\label{sub:Discrete distributions}

All discrete distributions support all integer types with sizes at least that
of |short|, unless stated otherwise.

\subsubsection{Bernoulli distribution}

\begin{equation*}
  \Prob(X = k;p) = kp + (1 - k)(1 - p) \qquad
  k \in \{0, 1\},\quad p \in [0, 1]
\end{equation*}
\begin{Verbatim}
template <typename IntType = bool>
class BernoulliDistribution;
\end{Verbatim}
Unlike other discrete distributions, the Bernoulli distribution supports any
integer type, including those with sizes smaller than that of |short|. The
implementation uses the simple fact that if $U$ is a standard uniform random
variable, than $\bbI_{[0,p)}(U)$ is Bernoulli distributed with success
probability $p$. This is not a drop-in replacement for
|std::bernoulli_distribution|, which is not a class template.

\subsubsection{Geometric distribution}

\begin{equation*}
  \Prob(X = k;p) = p(1-p)^k \qquad
  k \in \Natural,\quad p \in (0, 1]
\end{equation*}
\begin{Verbatim}
template <typename IntType = int>
class GeometricDistribution;
\end{Verbatim}
The implementation uses the fact that if $U$ is a standard uniform random
variable, than
\begin{equation*}
  X = \Floor{\ln U / \ln(1-p)}
\end{equation*}
is a Geometric random variable with success probability $p$.

\subsubsection{Uniform distribution}

\begin{equation*}
  \Prob(X = k;a,b) = \frac{1}{b - a + 1} \qquad
  k \in \{a,\dots,b\},\quad
  a \in \Integer,\quad b \in \{x \in \Integer: x \ge a\}
\end{equation*}
\begin{Verbatim}
template <typename IntType = int>
class UniformIntDistribution;
\end{Verbatim}
The specific algorithm used depends on the parameters. If $a = b$, then it
simply returns $a$. If $b - a + 1 = 2^W$ where $W$ is the number of bits of
|IntType|, then |UniformBitsDistribution| is used (see Section~\ref{sub:Uniform
bits distribution}). If $\max\{\Abs{a}, b\} < 2^{32}$, then it uses the fact
that if $U$ is a standard uniform random variable, then
\begin{equation*}
  X = \Floor{a + (b - a + 1) U}
\end{equation*}
is uniform on the set $\{a,\dots,b\}$. Otherwise the standard library is used.

\subsection{Multivariate distributions}
\label{sub:Multivariate distributions}

\subsubsection{Dirichlet distribution}

\mckl implements the Dirichlet distribution with \pdf,
\begin{equation*}
  f(x_{1:d};\alpha_{1:d}) = \frac{1}{\mathrm{B}(\alpha_{1:d})}
  \prod_{i=1}^d x_i^{\alpha_i - 1}
\end{equation*}
where
\begin{equation*}
  \mathrm{B}(\alpha_{1:d}) =
  \frac{\prod_{i=1}^d\Gamma(\alpha_i)}
  {\Gamma\Round[Big]{\sum_{i=1}^d\alpha_i}}
\end{equation*}
through the class template,
\begin{Verbatim}
template <typename RealType = double, size_t Dim = Dynamic>
class DirichletDistribution;
\end{Verbatim}
The template parameter |Dim| is the dimension of the distribution. If it is
positive, then the dimension is fixed. The distribution generator can be
constructed by,
\begin{Verbatim}
DirichletDistribution<double, Dim> dirichlet(alpha);
\end{Verbatim}
and if it is zero (recall that |Dynamic| is just an enumerator with value
zero), then the dimension has to be specified at runtime. The distribution
generator can be constructed by,
\begin{Verbatim}
DirichletDistribution<double> dirichlet(dim, alpha);
\end{Verbatim}
The parameter |alpha| can be either a pointer to a $d$-vector or a scalar. If
it is a scalar, say $\alpha$, then $\alpha_i = \alpha$ for $i = 1,\dots,d$. To
generate one random variate,
\begin{Verbatim}
dirichlet(rng, r);
rand(rng, dirichlet, r);
\end{Verbatim}
where the output parameter |r| is a pointer to a $d$-vector. Vectorized
generating is also possible. For example,
\begin{Verbatim}
dirichlet(rng, n, r);
rand(rng, dirichlet, n, r);
\end{Verbatim}
where the output parameter |r| is a pointer to an $n$ by $d$ matrix of row
major order.

\subsubsection{Multivariate Normal distribution}

\mckl implements the multivariate Normal distribution with \pdf,
\begin{equation*}
  f(x_{1:d};\mu_{1:d},\Sigma) = \frac{1}{\sqrt{(2\pi)^d\Abs{\Sigma}}}
  \exp\Curly[Big]{-\frac{1}{2}
    (x_{1:d} - \mu_{1:d})^{\transpose}\Sigma^{-1}(x_{1:d} - \mu_{1:d})}
\end{equation*}
where $\mu_{1:d}$ is the mean vector and $\Sigma$ is covariance matrix, through
the class template,
\begin{Verbatim}
template <typename RealType = double, size_t Dim = Dynamic>
class NormalMVDistribution;
\end{Verbatim}
At the time of writing, only |float| and |double| are supported types for the
template parameter |RealType|. The second template parameter |Dim| specify the
dimension of the distribution, $d$. If |Dim| is positive, then the dimension is
fixed. The distribution generator can be constructed by,
\begin{Verbatim}
NormalMVDistribution<double, Dim> normal_mv(mean, chol);
\end{Verbatim}
Otherwise, if |Dim| is zero, the dimension has to be specified at runtime. The
distribution generator can be constructed by,
\begin{Verbatim}
NormalMVDistribution<double> normal_mv(d, mean, chol);
\end{Verbatim}
In either case, the parameter |mean| is a pointer to the mean vector of length
$d$, and |chol| is a pointer to the lower triangular of the Cholesky
decomposition of the covariance matrix packed row by row. For those unfamiliar
with matrix storage schemes, this means that, |chol| is a vector of length
$d(d+1)/2$. Let $L$ be the lower triangular of the Cholesky decomposition, that
is $LL^{\transpose} = \Sigma$, then the vector is
$(L_{1,1},L_{2,1},L_{2,2},\dots,L_{d,d})^{\transpose}$. Further, both |mean|
and |chol| can also be scalars instead of pointers to vectors. If |mean| is a
scalar, say $\mu$, then the mean vector is assumed to be a $d$-vector with all
elements equal to $\mu$. If |chol| is a scalar, say $\sigma$, then it is
assumed that $L = \sigma I_d$ and thus the covariance matrix is $\Sigma =
\sigma^2 I_d$, where $I_d$ is the identity matrix. To generate a single
multivariate Normal random number,
\begin{Verbatim}
normal_mv(rng, r);
rand(rng, normal_mv, r);
\end{Verbatim}
where the output parameter |r| is a pointer to a $d$-vector. Vectorized
generating is also possible. For example,
\begin{Verbatim}
normal_mv(rng, n, r);
rand(rng, normal_mv, n, r);
\end{Verbatim}
where the output parameter |r| is a pointer to an $n$ by $d$ matrix of row
major order.

\section{Randomness test}
\label{sec:Randomness tests}

\mckl implements a few classical randomness tests in~\cite{Knuth:1997us}. It is
nowhere near as comprehensive as the \testu library~\cite{Lecuyer:2007hv}.
However, they are easier to use with \cpp{} \rng engines and distributions. All
tests below follows the same interfaces. They have the following operator,
\begin{Verbatim}
template <typename RNGType, typename DistributionType>
result_type operator()(RNGType &rng, DistributionType &distribution);
\end{Verbatim}
that accepts the \rng engine and distribution as input and returns the value of
the test statistic. They also have two methods that return the values of \pdf
and \cdf of the test statistic under the null hypothesis, respectively,
\begin{Verbatim}
double pdf(result_type s) const;
double cdf(result_type s) const;
\end{Verbatim}
Last, they have the following method,
\begin{Verbatim}
bool pass(double alpha, result_type s) const;
\end{Verbatim}
that returns if the test passes at significance level $\alpha$ given the test
statistic.

Most tests are implemented as class templates. There are a few common template
parameters. The first is $D$, which is the multiplier. Let $U_{1:n}$ be the
sequence of standard uniform random numbers, then $Y_{1:n}$ is the sequence of
random numbers in $\{0,\dots,D - 1\}$ with $Y_i = \Floor{DU_i}$. Tests with the
template parameter $D$ use the sequence $Y_{1:n}$ and others use the sequence
$U_{1:n}$ (see~\cite[pp.~61]{Knuth:1997us}). Another common template parameter
is $T$, which is the length of tuples. Some tests operate on the tuples
$X_{1:n}$, $X_i = (U_{iT},\dots,U_{(i+1)T})$.

\subsection{Serial test}
\label{sub:Serial test}

The templates,
\begin{Verbatim}
template <std::size_t D, std::size_t T>
using SerialTest = internal::SerialTestImpl<D, T, false>;

template <std::size_t D, std::size_t T>
using SerialOverTest = internal::SerialTestImpl<D, T, 1 < T>;
\end{Verbatim}
are aliases to implementations of the serial tests with independent or
overlapping tuples as described by~\cite[pp.~62]{Knuth:1997us}
and~\cite[ex.~24, pp.~78]{Knuth:1997us}, respectively. The constructors,
\begin{Verbatim}
SerialTest<D, T> test(n);
SerialOverTest<D, T> test_over(n);
\end{Verbatim}
accept the number of tuples as the argument. The tests generate $nT$ and $n$
random numbers, respectively. The equidistribution test using the
$\chi^2$-statistic~\cite[pp.~61]{Knuth:1997us} is a special case of this test
with $T = 1$.

\subsection{Gap test}
\label{sub:Gap test}

The class template,
\begin{Verbatim}
template <std::size_t NTrialMax = std::numeric_limits<std::size_t>::max()>
class GapTest;
\end{Verbatim}
implements the gap test~\cite[pp.~62]{Knuth:1997us}. The constructor,
\begin{Verbatim}
GapTest(std::size_t n, double alpha, double beta);
\end{Verbatim}
accepts the number of gaps, the lower and upper bound of the gap. The gap test
may not terminate given a deficient sequence. The template parameter
|NTrialMax| is the maximum number of random numbers to be generated for each
gap. If one of the gap requires more random numbers, then the test will
terminate and zero will be returned as the test statistic. In other words, the
test will fail to pass in this case.

\subsection{Poker test}
\label{sub:Poker test}

The class template,
\begin{Verbatim}
template <std::size_t D, std::size_t T>
class PokerTest;
\end{Verbatim}
implements the (simplified) poker test~\cite[pp.~63]{Knuth:1997us}. The
constructor,
\begin{Verbatim}
PokerTest(std::size_t n);
\end{Verbatim}
accepts the number of tuples.

\subsection{Coupon collector's test}
\label{sub:Coupon collector's test}

The class template,
\begin{Verbatim}
template <
    std::size_t D, std::size_t NTrialMax = std::numeric_limits<std::size_t>::max()>
class CouponCollectorTest;
\end{Verbatim}
implements the coupon collector's test~\cite[pp.~64]{Knuth:1997us}. The
constructor,
\begin{Verbatim}
CouponCollectorTest(std::size_t n);
\end{Verbatim}
accepts the number of tuples. Similar to the gap test, the test may not
terminate given a deficient sequence. The template parameter |NTrialMax| is the
maximum number of trials to generate one complete set.

\subsection{Permutation test}
\label{sub:Permutation test}

The class template,
\begin{Verbatim}
template <std::size_t T>
class PermutationTest;
\end{Verbatim}
implements the permutation test~\cite[pp.~65]{Knuth:1997us}. The constructor,
\begin{Verbatim}
PermutationTest(std::size_t n);
\end{Verbatim}
accepts the number of tuples.

\subsection{Run test}
\label{sub:Run test}

The templates,
\begin{Verbatim}
template <bool Up = true>
using RunTest = internal::RunTestImpl<false, Up>;

template <bool Up = true>
using RunIndepTest = internal::RunTestImpl<false, Up>;
\end{Verbatim}
are aliases to implementations of the run tests with dependent or
independent tuples as described by~\cite[pp.~66]{Knuth:1997us}
and~\cite[ex.~14, pp.~77]{Knuth:1997us}, respectively. The constructors,
\begin{Verbatim}
RunTest<Up> test(n);
RunIndepTest<Up> test_indep(n);
\end{Verbatim}
accept the number of samples and number runs, respectively. The former will
generate $n$ random numbers. The later will always terminate, but may take a
very long time if the sequence if deficient.

\subsection{Maximum-of-\texorpdfstring{$t$}{t} test}
\label{Maximum-of-t test}

The class template,
\begin{Verbatim}
template <std::size_t D, std::size_t T>
class MaximumOfTTest;
\end{Verbatim}
implements the maximum-of-$t$ test~\cite[pp.~70]{Knuth:1997us}. The test is
based on the euquidistribution test using the $\chi^2$-statistic with $D$
categories~\cite[pp.~61]{Knuth:1997us}. The constructor,
\begin{Verbatim}
MaximumOfTTest(std::size_t n);
\end{Verbatim}
accepts the number of tuples.

\subsection{Collision test}
\label{Collision test}

The class template,
\begin{Verbatim}
template <std::size_t D, std::size_t T>
class CollisionTest;
\end{Verbatim}
implements the collision test~\cite[pp.~70]{Knuth:1997us}. The constructor,
\begin{Verbatim}
Collision(std::size_t n);
\end{Verbatim}
accepts the number of tuples. The implementation is simplified by using the
asymptotic distribution of the number of collisions, a Poisson distribution
with mean,
\begin{equation*}
  \lambda = k\Round[Big]{
    \frac{n}{k} - 1 + \Round[Big]{1 - \frac{1}{k}}^n},\qquad k = D^T.
\end{equation*}
This is valid when both $n$ and $k$ are large and are of the same order or
$n \ll k$.

\subsection{Birthday spacings test}
\label{sub:Birthday spacings test}

The class templates,
\begin{Verbatim}
template <std::size_t D, std::size_t T>
class BirthdaySpacingsTest;
\end{Verbatim}
implements the birthday spacings test~\cite[pp.~71]{Knuth:1997us}. The
constructor,
\begin{Verbatim}
BirthdaySpacingsTest(std::size_t n);
\end{Verbatim}
accepts the number of tuples. Similar to the collision test, it use approximate
a Poisson distribution with mean,
\begin{equation*}
  \lambda = \frac{n^3}{4k},\qquad k = D^T.
\end{equation*}
This test is only useful when $\lambda$ is not too big and $n$ and $k$ are
large.
