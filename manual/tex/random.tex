% ============================================================================
%  MCKL/manual/tex/random.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2016, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Random number generating}
\label{chap:Random number generating}

\mckl has an \rng system for implementing Monte Carlo algorithms. Similar to
the standard library header |<random>|, there are mainly two parts of this
system. The first is a set of \rng engines that generate random integers. The
other is a set of distribution generators. The former are documented in
sections~\ref{sec:Counter-based RNG} to~\ref{sec:MKL RNG}, and the later in
sections~\ref{sec:Uniform bits distribution} to~\ref{sec:Multivariate
distribution}. \mckl also provides facilities for vectorized random number
generating (section~\ref{sec:Vectorized random number generating}), generating
distinctive seeds within a program (section~\ref{sec:Seeding counter-based
RNG}), and using multiple \rng{}s in parallel programs
(section~\ref{sec:Multiple RNG streams}). Last, in section~\ref{sec:Randomness
tests}, a few randomness tests are discussed.

\section{Vectorized random number generating}
\label{sec:Vectorized random number generating}

The generic function |rand| provides vectorized random number generating. There
are two main variants. The first operates on \rng engines and generates random
integers,
\begin{verbatim}
template <typename RNGType>
void rand(RNGType &rng, size_t n, typename RNGType::result_type *r);
\end{verbatim}
The effect of the function call, |rand(rng, n, r)|, is equivalent to the loop,
\begin{verbatim}
for (size_t i = 0; i != n; ++i)
    r[i] = rng();
\end{verbatim}
The results are always the same unless a non-deterministic \rng is used (see
section~\ref{sec:Non-deterministic RNG}). For some \rng{}s implemented in
\mckl, the vectorized function may have considerable performance advantage. See
appendix~\ref{chap:Performance of RNG}.

The second variant of |rand| is for generating distribution random variates,
\begin{verbatim}
template <typename RNGType, typename DistributionType>
void rand(RNGType &rng, const DistributionType &distribution, size_t n,
    typename DistributionType::result_type *r);
\end{verbatim}
For example,
\begin{verbatim}
NormalDistribution<double> normal;
rand(rng, normal, n, r);
\end{verbatim}
This is similar to the following loop,
\begin{verbatim}
for (size_t i = 0; i != n; ++i)
    r[i] = normal(rng);
\end{verbatim}
Depending on the type of |rng| and the distribution (including its parameters),
the vectorized function may have superior performance. See
appendix~\ref{chap:Performance of distribution}. However, the results are not
be exactly the same as using a loop.

\section{Counter-based \texorpdfstring{\rng}{RNG}}
\label{sec:Counter-based RNG}

The development by~\cite{Salmon:2011um} made high performance parallel \rng
much more accessible. The \rng{}s introduced in the paper use bijection $f_k$,
such that, for a sequence $\{c_i = i\}_{i\ge0}$, the sequence $\{y_i =
f_k(c_i)\}_{i\ge0}$ appears random. In addition, for $k_1 \ne k_2$, $f_{k_1}$
and $f_{k_2}$ generate two sequences that appear statistically independent.
Compared to more conventional \rng{}s which use recursions $y_i = f_k(y_{i -
1})$, these counter-based \rng{}s are much easier to setup in a parallelized
environment. If~$c$, the counter, is an unsigned integer with~$b$ bits,
and~$k$, the key, is an unsigned integer with~$d$ bits. Then for each $k$, the
\rng has a period~$2^b$. And there can be at most~$2^d$ independent streams.

\mckl defines the following class template as the interface,
\begin{verbatim}
template <typename ResultType, typename Generator>
class CounterEngine;
\end{verbatim}
where |ResultType| shall be an unsigned integer type and it is the output type
of the \rng engine. The type |Generator| is the class that actually implements
the algorithms. A few are implemented in \mckl and are introduced in the next
few sections.

\subsection{\texorpdfstring{\aes}{AES} round function based
\texorpdfstring{\rng}{RNG}}
\label{sub:AES-NI instructions based RNG}

\aes\footnote{\url{https://en.wikipedia.org/wiki/Advanced_Encryption_Standard}} round function based \rng{}s in~\cite{Salmon:2011um} are implemented in the following generator.
\begin{verbatim}
template <typename KeySeqType>
class AESNIGenerator;
\end{verbatim}
The corresponding \rng engine is,
\begin{verbatim}
template <typename ResultType, typename KeySeqType>
using AESNIEngine = CounterEngine<ResultType, AESNIGenerator<KeySeqType>;
\end{verbatim}
where |KeySeqType| is the class used to generate the sequences of round keys.
When \aesni\footnote{\url{https://en.wikipedia.org/wiki/AES_instruction_set}}
are available, they are used to for performance boost. Without going into
details, there are four types of sequence of round keys implemented by \mckl,

\begin{verbatim}
template <std::size_t Rounds = MCKL_AES128_ROUNDS>
using AES128KeySeq =
    internal::AESKeySeqImpl<Rounds, internal::AES128KeySeqGenerator>;

template <std::size_t Rounds = MCKL_AES192_ROUNDS>
using AES192KeySeq =
    internal::AESKeySeqImpl<Rounds, internal::AES192KeySeqGenerator>;

template <std::size_t Rounds = MCKL_AES256_ROUNDS>
using AES256KeySeq =
    internal::AESKeySeqImpl<Rounds, internal::AES256KeySeqGenerator>;

template <std::size_t Rounds = MCKL_ARS_ROUNDS, typename Constants = ARSConstants>
using ARSKeySeq = internal::ARSKeySeqImpl<Rounds, Constants>;
\end{verbatim}
The default rounds of the first three are 10, 12 and 14, respectively. And thus
they are equivalent to \aes-128, \aes-192, and \aes-256 block ciphers,
respectively. The last one is the \ars algorithm in~\cite{Salmon:2011um}. The
default rounds is 5, instead of 7 as in the paper, but the same as its \mkl
implementation. The trait class |Constants| defines the Weyl's sequence
constants. The only restriction on this trait class is that the following
expressions shall be valid,
\begin{verbatim}
constexpr uint64_t w0 = Constants::weyl::value[0];
constexpr uint64_t w1 = Constants::weyl::value[1];
\end{verbatim}
The member data |value| will not be \odr used. The default constant is taken
from the paper.

Correspondingly there are four \rng engines,
\begin{verbatim}
template <typename ResultType, std::size_t Rounds = MCKL_AES128_ROUNDS>
using AES128Engine = AESEngine<ResultType, AES128KeySeq<Rounds>>;

template <typename ResultType, std::size_t Rounds = MCKL_AES192_ROUNDS>
using AES192Engine = AESEngine<ResultType, AES192KeySeq<Rounds>>;

template <typename ResultType, std::size_t Rounds = MCKL_AES256_ROUNDS>
using AES256Engine = AESEngine<ResultType, AES256KeySeq<Rounds>>;

template <typename ResultType, std::size_t Rounds = MCKL_ARS_ROUNDS,
    typename Constants = ARSConstants>
using ARSEngine = AESEngine<ResultType, ARSKeySeq<Rounds, Constants>>;
\end{verbatim}
A few type aliases are defined for convenience.
\begin{verbatim}
using AES128 = AES128Engine<std::uint32_t>;
using AES192 = AES192Engine<std::uint32_t>;
using AES256 = AES256Engine<std::uint32_t>;
using ARS    = ARSEngine<std::uint32_t>;

using AES128_64 = AES128Engine<std::uint64_t>;
using AES192_64 = AES192Engine<std::uint64_t>;
using AES256_64 = AES256Engine<std::uint64_t>;
using ARS_64    = ARSEngine<std::uint64_t>;
\end{verbatim}

\subsection{Philox}
\label{sub:Philox}

The Philox algorithm in~\cite{Salmon:2011um} is implemented in the following
generator,
\begin{verbatim}
template <typename T, size_t K, size_t Rounds = MCKL_PHILOX_ROUNDS,
    typename Constants = PhiloxConstants<T, K>>
class PhiloxGenerator;
\end{verbatim}
The corresponding \rng engine is,
\begin{verbatim}
template <typename ResultType, typename T, size_t K,
    size_t Rounds = MCKL_PHILOX_ROUNDS,
    typename Constants = PhiloxConstants<T, K>>
using PhiloxEngine =
    CounterEngine<ResultType, PhiloxGenerator<T, K, Rounds, Constants>>;
\end{verbatim}
The template parameter |Constants| is a trait class that defines the Weyl's
sequence constants and the multipliers. The only restriction on this trait
class is the following expressions be valid,
\begin{verbatim}
// i is a compileting constant expression
constexpr T w = Constants::weyl::value[i];       // i = 0, ..., K / 2 - 1
constexpr T m = Constants::multiplier::value[i]; // i = 0, ..., K / 2 - 1
\end{verbatim}
The member data |value| will not be \odr used. The defaults are taken
from~\cite{Salmon:2011um}. Four engines are defined in \mckl,
\begin{verbatim}
template <typename ResultType>
using Philox2x32Engine = PhiloxEngine<ResultType, uint32_t, 2>;

template <typename ResultType>
using Philox4x32Engine = PhiloxEngine<ResultType, uint32_t, 4>;

template <typename ResultType>
using Philox2x64Engine = PhiloxEngine<ResultType, uint64_t, 2>;

template <typename ResultType>
using Philox4x64Engine = PhiloxEngine<ResultType, uint64_t, 4>;
\end{verbatim}
A few type aliases are defined for convenience,
\begin{verbatim}
using Philox2x32 = Philox2x32Engine<uint32_t>;
using Philox4x32 = Philox4x32Engine<uint32_t>;
using Philox2x64 = Philox2x64Engine<uint32_t>;
using Philox4x64 = Philox4x64Engine<uint32_t>;

using Philox2x32_64 = Philox2x32Engine<uint64_t>;
using Philox4x32_64 = Philox4x32Engine<uint64_t>;
using Philox2x64_64 = Philox2x64Engine<uint64_t>;
using Philox4x64_64 = Philox4x64Engine<uint64_t>;
\end{verbatim}

\subsection{Threefry}
\label{sub:Threefry}

The Threefry algorithm in~\cite{Salmon:2011um} is implemented in the following
generator,
\begin{verbatim}
template <typename T, size_t K, size_t Rounds = MCKL_THREEFRY_ROUNDS,
    typename Constants = ThreefryConstants<T, K>>
class ThreefryGenerator;
\end{verbatim}
The corresponding \rng engine is,
\begin{verbatim}
template <typename ResultType, typename T, size_t K,
    size_t Rounds = MCKL_THREEFRY_ROUNDS,
    typename Constants = ThreefryConstants<T, K>>
using ThreefryEngine =
    CounterEngine<ResultType, ThreefryGenerator<T, K, Rounds, Constants>>;
\end{verbatim}
The template parameter |Constants| is a trait class that defines the parity
constants, the rotation constants, and the permutation. The only restriction on
this trait class is the following expressions be valid,
\begin{verbatim}
// i, j are compile time constant expression
constexpr T k = Constants::parity::value;
constexpr int r = Constants::rotate::value[i][j];  // i = 0, ..., K / 2 - 1
                                                   // j = 1, ..., 8
constexpr size_t p = Constants::permute::value[i]; // i = 0, ..., K - 1
\end{verbatim}
The member data |value| will not be \odr used. The defaults are taken
from the skein\footnote{\url{http://www.skein-hash.info}} hash function
and~\cite{Salmon:2011um}. Six engines are defined in \mckl,
\begin{verbatim}
template <typename ResultType>
using Threefry2x32Engine = ThreefryEngine<ResultType, uint32_t, 2>;

template <typename ResultType>
using Threefry4x32Engine = ThreefryEngine<ResultType, uint32_t, 4>;

template <typename ResultType>
using Threefry2x64Engine = ThreefryEngine<ResultType, uint64_t, 2>;

template <typename ResultType>
using Threefry4x64Engine = ThreefryEngine<ResultType, uint64_t, 4>;

template <typename ResultType>
using Threefry8x64Engine = ThreefryEngine<ResultType, uint64_t, 8>;

template <typename ResultType>
using Threefry16x64Engine = ThreefryEngine<ResultType, uint64_t, 16>;
\end{verbatim}
In addition, three engines that are equivalent to Threefish-256, Threefish-512
and Threefish-1024 block ciphers are also defined,
\begin{verbatim}
template <typename ResultType>
using Threefish256Engine = ThreefryEngine<ResultType, uint64_t, 4, 72>;

template <typename ResultType>
using Threefish512Engine = ThreefryEngine<ResultType, uint64_t, 8, 72>;

template <typename ResultType>
using Threefish1024Engine = ThreefryEngine<ResultType, uint64_t, 16, 80>;
\end{verbatim}
A few type aliases are defined for convenience,
\begin{verbatim}
using Threefry2x32  = Threefry2x32Engine<uint32_t>;
using Threefry4x32  = Threefry4x32Engine<uint32_t>;
using Threefry2x64  = Threefry2x64Engine<uint32_t>;
using Threefry4x64  = Threefry4x64Engine<uint32_t>;
using Threefry8x64  = Threefry8x64Engine<uint32_t>;
using Threefry16x64 = Threefry16x64Engine<uint32_t>;

using Threefry2x32_64  = Threefry2x32Engine<uint64_t>;
using Threefry4x32_64  = Threefry4x32Engine<uint64_t>;
using Threefry2x64_64  = Threefry2x64Engine<uint64_t>;
using Threefry4x64_64  = Threefry4x64Engine<uint64_t>;
using Threefry8x64_64  = Threefry8x64Engine<uint64_t>;
using Threefry16x64_64 = Threefry16x64Engine<uint64_t>;

using Threefish256  = Threefish256Engine<uint32_t>;
using Threefish512  = Threefish512Engine<uint32_t>;
using Threefish1024 = Threefish1024Engine<uint32_t>;

using Threefish256_64  = Threefish256Engine<uint64_t>;
using Threefish512_64  = Threefish512Engine<uint64_t>;
using Threefish1024_64 = Threefish1024Engine<uint64_t>;
\end{verbatim}

\section{\texorpdfstring{\mkl \rng}{MKL RNG}}
\label{sec:MKL RNG}

\mkl provides some high performance \rng{}s. \mckl implements a wrapper class
\begin{verbatim}
template <MKL_INT BRNG, int Bits>
class MKLEngine;
\end{verbatim}
that makes them accessible as \cpp engines. The output is either 32- or 64-bit
unsigned integers. This is determined by the template parameter |Bits|, which
can only take one of these two values. The template paramter |BRNG| can be any
\mkl \brng macro that supports |viRngUniformBits32| (|Bits| is 32) or
|viRngUniformBits64| (|Bits| is 64). Type aliases are listed in below.
\begin{verbatim}
using MKL_MCG59 = MKLEngine<VSL_BRNG_MCG59, 32>;
using MKL_MCG59_64 = MKLEngine<VSL_BRNG_MCG59, 64>;

using MKL_MT19937 = MKLEngine<VSL_BRNG_MT19937, 32>;
using MKL_MT19937_64 = MKLEngine<VSL_BRNG_MT19937, 64>;

using MKL_MT2203 = MKLEngine<VSL_BRNG_MT2203, 32>;
using MKL_MT2203_64 = MKLEngine<VSL_BRNG_MT2203, 64>;

using MKL_SFMT19937 = MKLEngine<VSL_BRNG_SFMT19937, 32>;
using MKL_SFMT19937_64 = MKLEngine<VSL_BRNG_SFMT19937, 64>;

using MKL_NONDETERM = MKLEngine<VSL_BRNG_NONDETERM, 32>;
using MKL_NONDETERM_64 = MKLEngine<VSL_BRNG_NONDETERM, 64>;

using MKL_ARS5 = MKLEngine<VSL_BRNG_ARS5, 32>;
using MKL_ARS5_64 = MKLEngine<VSL_BRNG_ARS5, 64>;

using MKL_PHILOX4X32X10 = MKLEngine<VSL_BRNG_PHILOX4X32X10, 32>;
using MKL_PHILOX4X32X10_64 = MKLEngine<VSL_BRNG_PHILOX4X32X10, 64>;
\end{verbatim}
Note that, \mkl \rng{}s perform the best when they are used to generate vectors
of random numbers. These wrappers use a buffer to store such vectors. And thus
they have much larger state space than usual \rng{}s. When there are \mkl
routines for generating distribution random variates for one of the
distributions discussed later in sections~\ref{sec:Continuous distribution}
and~\ref{sec:Discrete distribution}, \mckl automatically uses these routines
for vectorized random number generating if the \rng is one of that listed
above. For example,
\begin{verbatim}
MKL_MT2203 rng;
NormalDistribution<double> normal;
normal(rng, n, r);       // MKL rountines used
rand(rng, normal, n, r); // MKL rountines used
\end{verbatim}
Note that, this is applicable when the distribution is a class in \mckl. It
does not work with classes such as |std::normal_distribution|. This is also
applicable when the distribution is not directly supported by \mkl, but can be
easily generated using other distributions, e.g., the Student's
$t$-distribution. In addition, it is also applicable if a distribution is a
special case of one of the distributions supported by \mkl, e.g., the
$\chi^2$-distribution.

\section{Non-deterministic \texorpdfstring{\rng}{RNG}}
\label{sec:Non-deterministic RNG}

If \rdrand\footnote{\url{https://en.wikipedia.org/wiki/RdRand}} instructions
are supported, \mckl also implements three non-deterministic \rng{}s,
|RDRAND16|, |RDRAND32| and |RDRAND64|. They output~16-, 32-, and~64-bit random
integers, respectively. \rdrand instructions may not return a random integer at
all. The \rng engine keeps trying until it succeeds. One can limit the maximum
number of trials by defining the configuration macro |MCKL_RDRAND_NTRIAL_MAX|.
A value of zero, the default, means the number of trials is unlimited. If it is
a positive number, and if after the specified number of trials no random
integer is returned by \rdrand instructions, zero is returned.

\section{Seeding counter-based \texorpdfstring{\rng}{RNG}}
\label{sec:Seeding counter-based RNG}

The singleton class template |Seed| can be used to generate distinctive seeds
sequentially. Each \rng class has its own seeding class. For example,
\begin{verbatim}
auto &seed = Seed<RNG>::instance();
RNG rng1(seed.get()); // Construct rng1
RNG rng2(seed.get()); // Construct rng2 with another seed
\end{verbatim}
The parameter of the template is the intended \rng type. One can save and set
the seed generator using standard streams. For example,
\begin{verbatim}
std::ifstream is("seed.txt");
if (is)
    is >> Seed<RNG>::instance();    // Read seed from a file
else
    Seed<RNG>::instance().set(101); // Set it manually
is.close();
// Using Seed
std::ofstream os("seed.txt");
os << Seed<RNG>::instance();        // Write the seed to a file
os.close();
\end{verbatim}
This way, if the simulation program needs to be run repeatedly, each time it
uses a different set of seeds. A single seed generator is enough for a single
program. However, it is more difficult to ensure that each computing node has a
distinctive set of seeds in a distributed system. A simple solution is to use
the |partition| method of |Seed|. For example,
\begin{verbatim}
Seed<RNG>::instance().partition(p, r);
\end{verbatim}
where~$p$ is the number of processes and~$r$ is the rank of the current node.
If $r_1$ and $r_2$ are ranks of two nodes, and $r_1 \ne r_2$, then $s_1 \ne
s_2$ for any two seeds generated on the two notes, respectively.

\subsection{Seeding behavior for different \texorpdfstring{\rng}{RNG}}
\label{sub:Seeding behavior for different RNG}

The class template |Seed| is actually a type alias,
\begin{verbatim}
template <typename ResultType,
    typename ID = std::integral_constant<size_t, sizeof(ResultType)>,
    bool Randomize = MCKL_SEED_RANDOMIZE, bool Atomic = MCKL_SEED_ATOMIC>
class SeedGenerator;

template <typename RNGType>
class Seed : public SeedGenerator<typename SeedType<RNGType>::type>;
\end{verbatim}
Each instance of |SeedGenerator| produces its own seed sequence. One can use
this property to initialize new generator.

The default |ResultType|, namely |SeedType<RNGType>::type| is defined such that
for all but the counter-based \rng{}s it is |unsigned|. For a counter-based
\rng{}, say |RNGType|, it is |RNGType::key_type|.

Let $N$ be the total number of bits of |ResultType|. If $N$ is not a multiple
of 32, then a compile time error will be raised. Otherwise, let $S =
\min\{N,64\}$ and $M = N / S$. The generator keep an $S$-bit unsigned integer
as its internal counter. Each time a new seed is requested, this counter is
incremented. If the template parameter |Atomic| is true, then this increment is
atomic and thread-safe. Let the old value be $s$. The generator first calculate
an $N$-bit unsigned integer $t$ as the following. If $M = 1$, then
\begin{align*}
  m &= (2^S - 1 - r)/p + 1, \\
  t &= (s \bmod m) p + r;
\end{align*}
where $p$ and $r$ are the arguments passed to the |partition| method. If $M >
1$, then
\begin{equation*}
  t = s + 2^{N - S}r;
\end{equation*}
If |Randomize| is false, then $t$ is returned as the requested seed, with
possible reordering of bytes on big-endian platforms such that the results are
exactly the same as on little-endian platforms. For example, if |ResultType| is
|std::array<int, 4>|, then the output seed has the same value as represented in
|int| regardless of endianness.

If |Randomize| is true, then $t$ is transformed through a bijection. If $N =
32$, then it is transformed using a 32-bit Speck block
cipher\footnote{\url{https://en.wikipedia.org/wiki/Speck_(cipher)}} with zero
key. If $N = 64, 128, 256, 512$, or $1024$, then it is transformed with the
bijection of |Threefry2x32|, |Threefry2x64|, |Threefry4x64|, |Threefry8x64|,
and |Threefry16x64| \rng{}s with zero key. Otherwise, it is transformed with
the Skein-512 hash function.

\section{Multiple \texorpdfstring{\rng}{RNG} streams}
\label{sec:Multiple RNG streams}

Earlier in section~\ref{sec:Particle} we introduced that |particle.rng(i)|
returns an independent \rng instance. This is actually done through a class
template called |RNGSet|. Three of them are implemented in \mckl. They all have
the same interface,
\begin{verbatim}
RNGSet<RNG> rng_set(N); // A set of N RNGs
rng_set.resize(n);      // Change the size of the set
rng_set[i];             // Get a reference to the i-th RNG
rng_set.reset();        // Re-seed each RNG in the set
\end{verbatim}
The first implementation is |RNGSetScalar|. As its name suggests, it is only a
wrapper of a single \rng. All calls to |rng_set[i]| returns a reference to the
same \rng. It is only useful when an |RNGSet| interface is required while the
thread-safety and other issues are not important.

The second implementation is |RNGSetVector|. It is an array of \rng{}s with
length~$N$. It has memory cost $O(N)$. Many of the counter-based \rng{}s (see
section~\ref{sec:Counter-based RNG}) have small state sizes and thus for
moderate~$N$, this cost is not significant. The method calls |rng_set[i]| and
|rng_set[j]| return independent \rng{}s if $i \ne j$. This implementation has
the advantage that the behavior of an algorithm can be deterministic and
reproducible (up to rounding errors) even when the scheduling of parallel
execution is dynamic, since each sample has its own \rng.

If \tbb is available, there is a third implementation, |RNGSetTBB|, which
uses thread-local storage (\tls). It has much smaller memory footprint than
|RNGSetVector| while maintains better thread-safety. The performance impact of
using \tls is minimal unless the computation at the calling site is trivial. To
minimize the \tls cost, a reference to the \rng shall be obtained first if it
is used multiple times. For example,
\begin{verbatim}
void eval_each(size_t, ParticleIndex<T> idx)
{
    auto &rng = idx.rng();
    // Use rng
}
\end{verbatim}

Last, an implementation |RNGSetTBBKPI| is provided if \tbb is available. It is
similar to |RNGSetTBB|. It consumes operating system native \tls keys. It has
potentially higher performance than |RNGSetTBB|. However, native \tls keys is a
scarce system resources. So this should be used with care.

The type alias |RNGSet| is defined to be |RNGSetTBB| if \tbb is available,
otherwise it is defined to be |RNGSetVector|. It is used by the |Particle|
class template. One can replace the type of \rng set used by |Particle<T>| with
a member type of |T|. For example,
\begin{verbatim}
class T
{
    public:
    using rng_set_type = RNGSetScalar<RNG>;
};
\end{verbatim}
One can also define their own replacement type, as long as it has the same
interface as the builtin ones.

\section{Uniform bits distribution}
\label{sec:Uniform bits distribution}

The class template,
\begin{verbatim}
template <typename UIntType>
class UniformBitsDistribution;
\end{verbatim}
is similar to the standard library's |std::independent_bits_engine|, except
that it always generates full size random integers and |UIntType| must have
size at least of that of |short|. That is, let~$W$ be the number of bits of
|UIntType|, then the output is uniform on the set $\{0,\dots,2^W - 1\}$. For
example,
\begin{verbatim}
UniformBitsDistribution<uint32_t> ubits;
ubits(rng); // Return 32-bit random integers
\end{verbatim}
Let $\rmin$ and $\rmax$ be the minimum and maximum of the random integers
generated by |rng|. Let $R = \rmax - \rmin + 1$. Let $r_i$ be consecutive
output of |rng()|. If there exists an integer $V > 0$ such that $R = 2^V$, then
the result is,
\begin{equation*}
  U = \sum_{k = 0}^{K - 1} (r_k - \rmin) 2^{kV} \bmod 2^W
\end{equation*}
where $K = \Ceil{W / V}$. Unlike |std::independent_bits_engine|, the
calculation can be vectorized, which leads to better performance. Note that,
all constants in the algorithm are computed at compile-time and the summation
is fully unrolled. There is no runtime overhead. In the case $\rmin = 0$ and $V
= W$, most optimizing compilers shall be able to generate instructions such
that the distribution does exactly nothing and returns the results of |rng()|
directly. If there does not exist an integer $V > 0$ such that $R = 2^V$, then
|std::indepdent_bits_engine| is used.

\section{Standard uniform distribution}
\label{sec:Standard uniform distribution}

\mckl provides five standard uniform distributions. They are all class
templates with a single template type parameter |RealType|. The random integers
produced by \rng{}s are transferred to~32- or~64-bit random integers through
the class |UniformBitsDistribution| before they are mapped to floating point
numbers within the interval $[0, 1]$. The integer type depends on |RealType|,
the range of the \rng{}, $R$, and |MCKL_U01_USE_64BITS_DOUBLE|, a configuration
macro. The exact relations are listed in table~\ref{tab:Intermediate integer
types of uniform distribution}. In the following, let~$W$ be the number of bits
of the integer type, and~$M$ be the number of significant bits (including the
implicit one) of |RealType|. We also denote the input random integers as~$U$
and the output random real numbers as~$X$.

\begin{table}
  \begin{tabularx}{\textwidth}{LlL}
    \toprule
    \texttt{RealType} & Conditions & Integer type \\
    \midrule
    \texttt{float}  & $\log_2 R \ge 64$ & \texttt{uint64\_t} \\
                    & Otherwise         & \texttt{uint32\_t} \\
    \texttt{double} & $\log_2 R \ge 64$ & \texttt{uint64\_t} \\
    & \texttt{MCKL\_U01\_USE\_64BITS\_DOUBLE} & \texttt{uint64\_t} \\
    & Otherwise & \texttt{uint32\_t} \\
    \texttt{long double} & Always & \texttt{uint64\_t} \\
    \bottomrule
  \end{tabularx}
  \caption{Intermediate integer types of uniform distribution}
  \label{tab:Intermediate integer types of uniform distribution}
\end{table}

The type |U01Distribution| is aliased to |U01CanonicalDistribution| if
|MCKL_U01_USE_FIXED_POINT| configuration macro is set to true. Otherwise it is
aliased to |U01CODistribution|.

\subsection{Canonical form}
\label{sub:Canonical form}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CanonicalDistribution;
\end{verbatim}
implements the uniform distribution on $[0, 1)$. Otherwise, it is implemented
through the mapping,
\begin{equation*}
  P = \Floor{(W + M - 1) / W},\qquad
  K = \max\{1, P\},\qquad
  X = \sum_{k=0}^{K - 1} U_k 2^{-(K - k)W}
\end{equation*}
This is equivalent to the standard library |std::generate_canonical|.

\subsection{Closed-closed interval}
\label{sub:Closed-closed interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CCDistribution;
\end{verbatim}
implements the uniform distribution on $[0, 1]$ through the mapping,
\begin{align*}
  P &= \min\{W - 1, M\} &
  V &= \begin{cases}
    U &\text{if } P + 1 < W \\
    \Floor{(U \bmod 2^{W - 1}) / 2^{W - P -2}} &\text{otherwise}
  \end{cases} \\
  Z &= (V \bmod 2) + V &
  X &= 2^{-(P + 1)} Z.
\end{align*}
The minimum and maximum are~$0$ and~$1$, respectively.

\subsection{Closed-open interval}
\label{sub:Closed-open interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CODistribution;
\end{verbatim}
implements the uniform distribution on $[0, 1)$ through the mapping,
\begin{equation*}
  P = \min\{W, M\},\qquad
  V = \Floor{U / 2^{W - P}},\qquad
  X = 2^{-P} V
\end{equation*}
The minimum and maximum are~$0$ and~$1 - 2^{-P}$, respectively.

\subsection{Open-closed interval}
\label{sub:Open-closed interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01OCDistribution;
\end{verbatim}
implements the uniform distribution on $(0, 1]$ through the mapping,
\begin{equation*}
  P = \min\{W, M\},\qquad
  V = \Floor{U / 2^{W - P}},\qquad
  X = 2^{-P} V + 2^{-P}
\end{equation*}
The minimum and maximum are~$2^{-P}$ and~$1$, respectively.

\subsection{Open-open interval}
\label{sub:Open-open interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CODistribution;
\end{verbatim}
implements the uniform distribution on $(0, 1)$ through the mapping,
\begin{equation*}
  P = \min\{W + 1, M\},\qquad
  V = \Floor{U / 2^{W + 1 - P}},\qquad
  X = 2^{-(P - 1)} V + 2^{-P}
\end{equation*}
The minimum and maximum are~$2^{-P}$ and~$1 - 2^{-P}$, respectively.

\section{Continuous distribution}
\label{sec:Continuous distribution}

\subsection{Arcsine distribution}
\label{sub:Arcsine distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ArcsineDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\alpha,\beta) = \frac{1}{\pi\sqrt{(x - \alpha)(\beta - x)}},\qquad
  x \in [a, b],\quad a \in (0,\infty),\quad b \in (0,\infty),
\end{equation*}
using the inverse method.

\subsection{Beta distribution}
\label{sub:Beta distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class BetaDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\alpha,\beta) =
  \frac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)}
  x^{\alpha - 1}(1 - x)^{\beta - 1},\qquad
  x \in (0, 1),\quad \alpha \in (0,\infty),\quad \beta \in (0,\infty).
\end{equation*}
The specific algorithm used depends on the parameters. If $\alpha = 1/2$ and
$\beta = 1/2$, or $\alpha = 1$ or $\beta = 1$, then the inverse method is used.
If $\alpha > 1$ and $\beta > 1$, the method in~\cite{Cheng:1978jl} is used.
Otherwise, let $K = 0.852$, $C = -0.956$, and $D = \beta + K\alpha^2 + C$. If
$\alpha < 1$, $\beta < 1$ and $D \le 0$, then JÃ¶hnk's
method~\cite[sec.~3.5]{Devroye:1986gi} is used. In all other cases, one of the
switching algorithms in~\cite{Atkinson:1979es} is used.

\subsection{Cauchy distribution}
\label{sub:Cauchy distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class CauchyDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) =
  \frac{1}{\pi b\Round[Big]{1 + \Round[Big]{\frac{x - a}{b}}^2}},\qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0,\infty),
\end{equation*}
using the inverse method.

\subsection{\texorpdfstring{$\chi^2$}{Chi-squared}-distribution}
\label{Chi-squared-distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ChiSquaredDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;n) = \frac{x^{n/2 - 1}\EE^{-x/2}}{2^{n/2}\Gamma(n/2)},\qquad
  x \in (0,\infty),\quad n \in (0,\infty),
\end{equation*}
The implementation uses the fact that if~$X$ is a Gamma random variable with
shape $n / 2$ and scale~$2$, then~$X$ is also $\chi^2$-distributed with degree
of freedom $n$.

\subsection{Exponential distribution}
\label{sub:Exponential distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ExponentialDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\lambda) = \lambda\EE^{-\lambda x},\qquad
  x \in [0,\infty),\quad \lambda \in (0,\infty),
\end{equation*}
using the inverse method.

\subsection{Extreme value distribution}
\label{sub:Extreme value distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ExtremeValueDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) =
  \frac{1}{b}\exp\Curly[Big]{
    \frac{a - x}{b} - \exp\Curly[Big]{\frac{a - x}{b}}},\qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Fisher's \texorpdfstring{$F$}{F}-distribution}
\label{sub:Fisher's F-distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class FisherFDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{align*}
  & f(x;m,n) =
  \frac{\Gamma\Round[Big]{\frac{m + n}{2}}}{
    \Gamma\Round[Big]{\frac{m}{2}}\Gamma\Round[Big]{\frac{n}{2}}}
  \Round[Big]{\frac{m}{n}}^{m/2} x^{m / 2 - 1}
  \Round[Big]{1 + \frac{m}{n}x}^{-(m + n) / 2} \\
  & x \in [0, \infty),\quad m \in (0, \infty),\quad n \in (0, \infty).
\end{align*}
The implementation uses the fact that if~$U$ and~$V$ are $\chi^2$-distributed
random variables with degrees of freedom~$m$ and~$n$, respectively, and they
are independent, then $X = (U / V)(m / n)$ is a Fisher's $F$-distributed random
variable with the respective degrees of freedom.

\subsection{Gamma distribution}
\label{sub:Gamma distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class GammaDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\alpha,\beta) =
  \frac{\EE^{-x/\beta}}{\Gamma(\alpha)}\beta^{-\alpha}x^{\alpha-1},\qquad
  x \in (0, \infty),\quad \alpha \in (0, \infty),\quad \beta \in (0, \infty).
\end{equation*}
The specific algorithm used depends on the parameters. If $\alpha = 1$, it
becomes the exponential distribution. If $0 < \alpha < 0.6$, it is generated
through transformation of exponential power
distribution~\cite[sec~2.6]{Devroye:1986gi}. If $0.6\le\alpha<1$, then
rejection method from the Weibull distribution is
used~\cite[sec.~3.4]{Devroye:1986gi}. If $\alpha > 1$, then the method
in~\cite{Marsaglia:2000vq} is used.

\subsection{Laplace distribution}
\label{sub:Laplace distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LaplaceDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{1}{2b}\exp\Curly[Big]{-\frac{\Abs{x - a}}{b}},\qquad
  x \in \Real,\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Levy distribution}
\label{sub:Levy distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LevyDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) =
  \sqrt{\frac{b}{2\pi}}
  \frac{\exp\Curly[Big]{-\frac{b}{2(x - a)}}}{(x - a)^{3/2}},\qquad
  x \in [a, \infty),\quad a \in \Real,\quad b \in (0, \infty).
\end{equation*}
The implementation uses the fact that if~$Z$ is a standard Normal random
variable, then $X = a + b / Z^2$ is Levy distributed with location~$a$ and
scale~$b$.

\subsection{Logistic distribution}
\label{sub:Logistic distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LaplaceDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{1}{4b}\mathrm{sech}^2\Round[Big]{\frac{x - a}{2b}},\qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Log-normal distribution}
\label{sub:Log-normal distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LognormalDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;m,s) =
  \frac{1}{x\sigma\sqrt{2\pi}}
  \exp\Curly[Big]{-\frac{(\ln x - m)^2}{2\sigma^2}},\qquad
  x \in (0, \infty),\quad m \in \Real,\quad s \in (0, \infty).
\end{equation*}
The implementation uses the fact that if~$Z$ is a standard Normal random
variable, then $X = \exp\{m + sZ\}$ is Log-normal distributed with location~$m$
and scale~$s$.

\subsection{Normal distribution}
\label{sub:Normal distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class NormalDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\mu,\sigma) =
  \frac{1}{\sqrt{2\pi\sigma^2}}
  \exp\Curly[Big]{-\frac{(x-\mu)^2}{2\sigma^2}},\qquad
  x \in \Real,\quad \mu \in \Real,\quad \sigma \in (0, \infty),
\end{equation*}
using the Box-Muller method~\cite{Box:1958hv}.

\subsection{Pareto distribution}
\label{sub:Pareto distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ParetoDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{a b^a}{x^{a + 1}},\qquad
  x \in [b, \infty),\quad a \in [0, \infty),\quad b \in [0, \infty),
\end{equation*}
using the inverse method.

\subsection{Rayleigh distribution}
\label{sub:Rayleigh distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class RayleighDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\sigma) =
  \frac{x}{\sigma^2}\exp\Curly[Big]{-\frac{x^2}{2\sigma^2}},\qquad
  x \in [0, \infty),\quad \sigma \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Stable distribution}
\label{sub:Stable distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class StableDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{align*}
  &f(x;\alpha,\beta,a,b) =
  \frac{1}{2\pi}\int_{\infty}^{\infty}
  \varphi(t;\alpha,\beta,a,b)\EE^{-ixt}\intd t\\
  &\varphi(t;\alpha,\beta,a,b) =
  \exp\{ita - \Abs{bt}^{\alpha}(1 - i\beta\mathrm{sgn}(t)\Phi(t;\alpha))\} \\
  &\Phi(t;\alpha) = \begin{cases}
    \tan\Round[big]{\frac{\pi}{2}\alpha} & \alpha \ne 1 \\
    -\frac{2}{\pi}\log\Abs{t}            & \alpha = 1
  \end{cases} \\
  & x \in \Real,\quad
  \alpha \in (0, 2],\quad \beta \in [-1, 1],\quad
  a \in \Real,\quad b \in (0, \infty).
\end{align*}
The implementation uses the method in~\cite{Chambers:1976dv}. Note that, some
other distributions implemented in \mckl, such as the Cauchy distribution
($\alpha = 1$, $\beta = 0$), the Levy distribution ($\alpha = 1/2$, $\beta =
1$), and the Normal distribution ($\alpha = 2$), are all special cases of the
stable distribution. It is possible to use implementations of those
distributions to speed up the stable distribution in special cases. However,
\mckl does not do so. Every distribution implemented in \mckl goes through some
basic statistical tests to ensure correctness. Without a tractable distribution
function in general, the stable distribution is somehow more difficult to test
than others. Therefore, we use these special cases to tests the implementation,
which is generic with respect to parameter values. In applications, for
generating random numbers from distributions of those special cases, use the
dedicated classes instead of this one. There are also a few distributions not
implemented by \mckl, but are special cases of the stable distribution, such as
the Landau distribution ($\alpha = 1$, $\beta = 1$) and Holtsmark distribution
($\alpha = 3/2$, $\beta = 0$), to name just two of them.

\subsection{Student's \texorpdfstring{$t$}{t}-distribution}
\label{sub:Student's t-distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class StudentTDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;n) =
  \frac{\Gamma\Round[Big]{\frac{n + 1}{2}}}
  {\sqrt{n\pi}\Gamma\Round[Big]{\frac{n}{2}}}
  \Round[Big]{1 + \frac{x^2}{n}}^{-(n + 1)/2},\qquad
  x \in \Real,\quad n \in (0, \infty).
\end{equation*}
The implementation uses the fact that if~$Z$ is a standard Normal random
variable, $V$ is a $\chi^2$-distributed random variable with degree of freedom
$n$, and they are independent, then $X = Z/\sqrt{V / n}$ is Student's
$t$-distributed with the respective degree of freedom.

\subsection{Uniform real distribution}
\label{sub:Uniform real distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class UniformRealDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{1}{b - a},\qquad
  x \in [a, b),\quad a \in \Real,\quad b \in (a, \infty),
\end{equation*}
using the inverse method.

\subsection{Weibull distribution}
\label{sub:Weibull distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class WeibullDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{a}{b}\Round[Big]{\frac{x}{b}}^{a - 1}
  \exp\Curly[Big]{-\Round[Big]{\frac{x}{b}}^a},\qquad
  x \in [0, \infty),\quad a \in (0, \infty),\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\section{Discrete distribution}
\label{sec:Discrete distribution}

\subsection{Bernoulli distribution}
\label{sub:Bernoulli distribution}

The class template,
\begin{verbatim}
template <typename IntType = bool>
class BernoulliDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  \Prob(X = k;p) = kp + (1 - k)(1 - p),\qquad
  k \in \{0, 1\},\quad p \in [0, 1].
\end{equation*}
Unlike other discrete distributions, the Bernoulli distribution supports any
integer type, including those with sizes smaller than that of |short|. The
implementation uses the simple fact that if~$U$ is a standard uniform random
variable, than $\bbI_{[0,p)}(U)$ is Bernoulli distributed with success
probability~$p$. This is not a drop-in replacement for
|std::bernoulli_distribution|, which is not a class template.

\subsection{Geometric distribution}
\label{sub:Geometric distribution}

The class template,
\begin{verbatim}
template <typename IntType = int>
class GeometricDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  \Prob(X = k;p) = p(1-p)^k,\qquad
  k \in \Natural,\quad p \in (0, 1].
\end{equation*}
The implementation uses the fact that if~$U$ is a standard uniform random
variable, then $X = \Floor{\ln U / \ln(1-p)}$ is a Geometric random variable
with success probability~$p$.

\subsection{Uniform distribution}
\label{sub:Uniform distribution}

The class template,
\begin{verbatim}
template <typename IntType = int>
class UniformIntDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  \Prob(X = k;a,b) = \frac{1}{b - a + 1},\qquad
  k \in \{a,\dots,b\},\quad
  a \in \Integer,\quad b \in \{x \in \Integer: x \ge a\}.
\end{equation*}
The specific algorithm used depends on the parameters. If $a = b$, then it
simply returns~$a$. If $b - a + 1 = 2^W$ where~$W$ is the number of bits of
|IntType|, then |UniformBitsDistribution| is used (see section~\ref{sec:Uniform
bits distribution}). If $\max\{\Abs{a}, b\} < 2^{32}$, then it uses the fact
that if~$U$ is a standard uniform random variable, then $X = \Floor{a + (b - a
+ 1) U}$ is uniform on the set $\{a,\dots,b\}$. Otherwise the standard library
is used.

\section{Multivariate distribution}
\label{sec:Multivariate distribution}

\subsection{Dirichlet distribution}
\label{sub:Dirichlet distribution}

The class template,
\begin{verbatim}
template <typename RealType = double, size_t Dim = Dynamic>
class DirichletDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x_{1:d};\alpha_{1:d}) =
  \frac{\Gamma\Round[Big]{\sum_{i=1}^d\alpha_i}}{\prod_{i=1}^d\Gamma(\alpha_i)}
  \prod_{i=1}^d x_i^{\alpha_i - 1},\qquad
  \sum_{i=1}^d x_i = 1,\quad
  x_{1:d}\in(0,1)^d,\quad
  \alpha_{1:d}\in(0,\infty)^d.
\end{equation*}
The template parameter |Dim| is the dimension of the distribution. If it is
positive, then the dimension is fixed. The distribution generator can be
constructed by,
\begin{verbatim}
DirichletDistribution<double, Dim> dirichlet(alpha);
\end{verbatim}
and if it is zero (recall that |Dynamic| is just an enumerator with value
zero), then the dimension has to be specified at runtime. The distribution
generator can be constructed by,
\begin{verbatim}
DirichletDistribution<double> dirichlet(dim, alpha);
\end{verbatim}
The parameter |alpha| can be either a pointer to a $d$-vector or a scalar. If
it is a scalar, say $\alpha$, then $\alpha_i = \alpha$ for $i = 1,\dots,d$. To
generate one random variate,
\begin{verbatim}
dirichlet(rng, r);
rand(rng, dirichlet, r);
\end{verbatim}
where the output parameter |r| is a pointer to a $d$-vector. Vectorized
generating is also possible,
\begin{verbatim}
dirichlet(rng, n, r);
rand(rng, dirichlet, n, r);
\end{verbatim}
where the output parameter |r| is a pointer to an~$n$ by~$d$ matrix of row
major order.

\subsection{Multivariate Normal distribution}
\label{sub:Multivariate Normal distribution}

The class template,
\begin{verbatim}
template <typename RealType = double, size_t Dim = Dynamic>
class NormalMVDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{align*}
  &f(x_{1:d};\mu_{1:d},\Sigma) = \frac{1}{\sqrt{(2\pi)^d\Abs{\Sigma}}}
  \exp\Curly[Big]{-\frac{1}{2}(x_{1:d} -
  \mu_{1:d})^{\transpose}\Sigma^{-1}(x_{1:d} - \mu_{1:d})},\\
  &x_{1:d}\in\Real^d,\quad
  \mu_{1:d}\in\Real^d,\quad
  \Sigma\in
  \{\,\text{positive semi-definite }d\text{ by }d\text{ matrix}\,\}.
\end{align*}
At the time of writing, only |float| and |double| are supported types for the
template parameter |RealType|. The second template parameter |Dim| specify the
dimension of the distribution, $d$. If |Dim| is positive, then the dimension is
fixed. The distribution generator can be constructed by,
\begin{verbatim}
NormalMVDistribution<double, Dim> normal_mv(mean, chol);
\end{verbatim}
Otherwise, if |Dim| is zero, the dimension has to be specified at runtime. The
distribution generator can be constructed by,
\begin{verbatim}
NormalMVDistribution<double> normal_mv(d, mean, chol);
\end{verbatim}
In either case, the parameter |mean| is a pointer to the mean vector of length
$d$, and |chol| is a pointer to the lower triangular of the Cholesky
decomposition of the covariance matrix packed row by row. For those unfamiliar
with matrix storage schemes, this means that, |chol| is a vector of length
$d(d+1)/2$. Let~$L$ be the lower triangular of the Cholesky decomposition, that
is $LL^{\transpose} = \Sigma$, then the vector is
$(L_{1,1},L_{2,1},L_{2,2},\dots,L_{d,d})^{\transpose}$. Further, both |mean|
and |chol| can also be scalars instead of pointers to vectors. If |mean| is a
scalar, say $\mu$, then the mean vector is assumed to be a $d$-vector with all
elements equal to $\mu$. If |chol| is a scalar, say $\sigma$, then it is
assumed that $L = \sigma I_d$ and thus the covariance matrix is $\Sigma =
\sigma^2 I_d$, where $I_d$ is the identity matrix. To generate a single
multivariate Normal random number,
\begin{verbatim}
normal_mv(rng, r);
rand(rng, normal_mv, r);
\end{verbatim}
where the output parameter |r| is a pointer to a $d$-vector. Vectorized
generating is also possible,
\begin{verbatim}
normal_mv(rng, n, r);
rand(rng, normal_mv, n, r);
\end{verbatim}
where the output parameter |r| is a pointer to an~$n$ by~$d$ matrix of row
major order.

\section{Randomness test}
\label{sec:Randomness tests}

\mckl implements a few classical randomness tests in~\cite{Knuth:1997us}. It is
nowhere near as comprehensive as the \testu library~\cite{Lecuyer:2007hv}.
However, they are easier to use with \cpp \rng engines and distributions. All
tests below follows the same interfaces. They have the following operator,
\begin{verbatim}
template <typename RNGType, typename DistributionType>
result_type operator()(RNGType &rng, DistributionType &distribution);
\end{verbatim}
that accepts the \rng engine and distribution as input and returns the value of
the test statistic. They also have two methods that return the values of \pdf
and \cdf of the test statistic under the null hypothesis, respectively,
\begin{verbatim}
double pdf(result_type s) const;
double cdf(result_type s) const;
\end{verbatim}
Last, they have the following method,
\begin{verbatim}
bool pass(double alpha, result_type s) const;
\end{verbatim}
that returns if the test passes at significance level $\alpha$ given the test
statistic.

Most tests are implemented as class templates. There are a few common template
parameters. The first is~$D$, which is the multiplier. Let $U_{1:n}$ be the
sequence of standard uniform random numbers, then $Y_{1:n}$ is the sequence of
random numbers in $\{0,\dots,D - 1\}$ with $Y_i = \Floor{DU_i}$. Tests with the
template parameter~$D$ use the sequence $Y_{1:n}$ and others use the sequence
$U_{1:n}$ (see~\cite[pp.~61]{Knuth:1997us}). Another common template parameter
is~$T$, which is the length of tuples. Some tests operate on the tuples
$X_{1:n}$, $X_i = (U_{iT},\dots,U_{(i+1)T})$.

\subsection{Serial test}
\label{sub:Serial test}

The template,
\begin{verbatim}
template <size_t D, size_t T, bool Overlap>
using SerialTest = internal::SerialTestImpl<D, T, Overlap && 1 < T>;
\end{verbatim}
is a type alias to implementations of the serial tests with independent
(|Overlap| is false) or overlapping tuples (|Overlap| is true) as described
by~\cite[pp.~62]{Knuth:1997us} and~\cite[ex.~24, pp.~78]{Knuth:1997us},
respectively. The constructor,
\begin{verbatim}
SerialTest<D, T, Overlap> test(n);
\end{verbatim}
accepts the number of tuples as the argument. The tests generate~$nT$ and~$n$
random numbers, respectively. The equidistribution test using the
$\chi^2$-statistic~\cite[pp.~61]{Knuth:1997us} is a special case of this test
with $T = 1$.

\subsection{Gap test}
\label{sub:Gap test}

The class template,
\begin{verbatim}
template <size_t NTrialMax = std::numeric_limits<size_t>::max()>
class GapTest;
\end{verbatim}
implements the gap test~\cite[pp.~62]{Knuth:1997us}. The constructor,
\begin{verbatim}
GapTest(size_t n, double alpha, double beta);
\end{verbatim}
accepts the number of gaps, the lower and upper bounds of the gap. The gap test
may not terminate given a deficient sequence. The template parameter
|NTrialMax| is the maximum number of random numbers to be generated for one
gap.

\subsection{Poker test}
\label{sub:Poker test}

The class template,
\begin{verbatim}
template <size_t D, size_t T>
class PokerTest;
\end{verbatim}
implements the (simplified) poker test~\cite[pp.~63]{Knuth:1997us}. The
constructor,
\begin{verbatim}
PokerTest(size_t n);
\end{verbatim}
accepts the number of tuples.

\subsection{Coupon collector's test}
\label{sub:Coupon collector's test}

The class template,
\begin{verbatim}
template <size_t D, size_t NTrialMax = std::numeric_limits<size_t>::max()>
class CouponCollectorTest;
\end{verbatim}
implements the coupon collector's test~\cite[pp.~64]{Knuth:1997us}. The
constructor,
\begin{verbatim}
CouponCollectorTest(size_t n);
\end{verbatim}
accepts the number of tuples. Similar to the gap test, the test may not
terminate given a deficient sequence. The template parameter |NTrialMax| is the
maximum number of trials to generate one complete set.

\subsection{Permutation test}
\label{sub:Permutation test}

The class template,
\begin{verbatim}
template <size_t T>
class PermutationTest;
\end{verbatim}
implements the permutation test~\cite[pp.~65]{Knuth:1997us}. The constructor,
\begin{verbatim}
PermutationTest(size_t n);
\end{verbatim}
accepts the number of tuples.

\subsection{Run test}
\label{sub:Run test}

The templates,
\begin{verbatim}
template <bool Indepenent, bool Up = true>
using RunTest = internal::RunTestImpl<Independent, Up>;
\end{verbatim}
is a type alias to implementations of the run tests with dependent or
independent tuples as described by~\cite[pp.~66]{Knuth:1997us}
and~\cite[ex.~14, pp.~77]{Knuth:1997us}, respectively. The constructors,
\begin{verbatim}
RunTest<Independent, Up> test(n);
\end{verbatim}
accept the number of samples and number runs, respectively. The independent
test generates~$n$ random numbers. The dependent test always terminates,
but may take a very long time if the sequence is deficient.

\subsection{Maximum-of-\texorpdfstring{$t$}{t} test}
\label{Maximum-of-t test}

The class template,
\begin{verbatim}
template <size_t D, size_t T>
class MaximumOfTTest;
\end{verbatim}
implements the maximum-of-$t$ test~\cite[pp.~70]{Knuth:1997us}. The test is
based on the euquidistribution test using the $\chi^2$-statistic with~$D$
categories~\cite[pp.~61]{Knuth:1997us}. The constructor,
\begin{verbatim}
MaximumOfTTest(size_t n);
\end{verbatim}
accepts the number of tuples.

\subsection{Collision test}
\label{Collision test}

The class template,
\begin{verbatim}
template <size_t D, size_t T>
class CollisionTest;
\end{verbatim}
implements the collision test~\cite[pp.~70]{Knuth:1997us}. The constructor,
\begin{verbatim}
Collision(size_t n);
\end{verbatim}
accepts the number of tuples. The implementation is simplified by using the
asymptotic distribution of the number of collisions, a Poisson distribution
with mean,
\begin{equation*}
  \lambda = k\Round[Big]{
    \frac{n}{k} - 1 + \Round[Big]{1 - \frac{1}{k}}^n},\qquad k = D^T.
\end{equation*}
This is valid when both~$n$ and~$k$ are large and are of the same order or
$n \ll k$.

\subsection{Birthday spacings test}
\label{sub:Birthday spacings test}

The class templates,
\begin{verbatim}
template <size_t D, size_t T>
class BirthdaySpacingsTest;
\end{verbatim}
implements the birthday spacings test~\cite[pp.~71]{Knuth:1997us}. The
constructor,
\begin{verbatim}
BirthdaySpacingsTest(size_t n);
\end{verbatim}
accepts the number of tuples. It uses approximate a Poisson distribution with
mean, $\lambda = n^3/4k$, $k = D^T$. This test is only useful when $\lambda$ is
not too big and~$n$ and~$k$ are large.
