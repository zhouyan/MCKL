% ============================================================================
%  MCKL/manual/tex/utility.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2016, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Utilities}
\label{chap:Utilities}

The library provides some utilities for writing Monte Carlo simulation
programs.

\section{Aligned memory allocation}
\label{sec:Aligned memory allocation}

The standard library class |std::allocator| is used by containers to allocate
memory. It works fine in most cases. However, sometime it is desirable to
allocate memory aligned by a certain boundary. The library provides the class
template,
\begin{Verbatim}
template <
    typename T,
    size_t Alignment = AlignmentTrait<T>::value,
    typename Memory = AlignedMemory>
class Allocator;
\end{Verbatim}
which conforms to the |std::allocator| interface. The address of the pointer
returned by the |allocate| method will be a multiple of |Alignment|. The value
of alignment has to be positive, larger than |sizeof(void *)|, and a power of
two. Violating any of these conditions will result in compile-time error. The
last template parameter |Memory| shall have two static methods,
\begin{Verbatim}
static void *aligned_malloc(size_t n, size_t alignment);
static void aligned_free(void *ptr);
\end{Verbatim}
The method |aligned_malloc| shall behave similar to |std::malloc| with the
additional alignment requirement. It shall return a null pointer if it fails to
allocate memory. In any other case, including zero input size, it shall return
a reachable non-null pointer. The method |aligned_free| shall behave similar to
|std::free|. It shall be able to handle a null pointer as its input. The
library provides three implementations, discussed below. The default argument
|AlignedMemory| is an alias to one of them by default. It can be changed by
defining the macro |MCKL_ALIGNED_MEMORY_TYPE|.

\paragraph{\texttt{AlignedMemoryTBB}} This class uses the functions from the
\tbb library. This is the default method if |MCKL_USE_TBB_MALLOC| is true.

\paragraph{\texttt{AlignedMemorySYS}} This class uses operation system specific
functions. If this class is define, it is the default method if
|MCKL_USE_TBB_MALLOC| is false.

\paragraph{\texttt{AlignedMemorySTD}} This class uses functions in the standard
library and padding the memory manually when the alignment is insufficient. It
is the last resort method that the library will use.

The default alignment depends on the type |T|. If it is a scalar type, then the
alignment is |MCKL_ALIGNMENT|, whose default is 32. This alignment is
sufficient for modern \simd operations, such as \avx. For other types, the
alignment is the either |alignof(T)| or |MCKL_ALIGNMENT_MIN|, whose default is
16. The maximum between the two will be used. A container type are defined for
convenience, as a drop-in replacement for |std::vector|. It is merely a type
alias with a different default allocator,
\begin{Verbatim}
template <typename T>
using Vector = std::vector<T, Allocator<T>>;
\end{Verbatim}
Any function template that accepts |std::vector| will also accept this class,
as long as the template is defined correctly. For example,
\begin{Verbatim}
template <typename T, typename Alloc>
void func(std::vector<T, Alloc> &vec);
\end{Verbatim}

\section{Sample covariance}
\label{sec:Sample covariance}

The library provides the class template
\begin{Verbatim}
template <typename RealType = double>
class Covariance;
\end{Verbatim}
to estimate the sample covariance $\Sigma$, for samples $x\in\Real^p$, $p\ge1$,
\begin{align*}
  \Sigma_{i,j} &= \frac{\sum_{i=1}^N w_i}
  {(\sum_{i=1}^N w_i)^2 - \sum_{i=1}^n w_i^2}
  \sum_{k=1}^N w_k (x_{k,i} - \bar{x}_i)(x_{k,j} - \bar{x}_j) \\
  \bar{x}_i &= \frac{1}{\sum_{i=1}^N w_i}\sum_{k=1}^N w_k x_{k,i}
\end{align*}
where $x_{i,j}$ is the $j$\ith component of the $i$\ith sample, and $w_i$ is
the weight of the $i$\ith sample. At the time of writing, only |float| and
|double| are supported. The class has the following operator as its interface,
\begin{Verbatim}
void operator()(
    MatrixLayout layout,
    size_t n,
    size_t p,
    const RealType *x,
    const RealType *w,
    RealType *mean,
    RealType *cov,
    MatrixLayout cov_layout = RowMajor,
    bool cov_upper = false,
    bool cov_packed = false)
\end{Verbatim}
It computes the sample covariance matrix $\Sigma$,
where $x$ is the $n$ by $p$ matrix of samples, and $w$ is the $n$-vector of
weights. Below we given detailed description of each parameter,

\begin{description}
  \item[\texttt{layout}] The storage layout of sample matrix $x$.
  \item[\texttt{n}] The number of samples.
  \item[\texttt{p}] The dimension of samples.
  \item[\texttt{x}] The sample matrix. If it is a null pointer, then no
    computation is done.
  \item[\texttt{w}] The weight vector. If it is a null pointer, then $w_i = 1$
    for $i = 1,\dots,n$.
  \item[\texttt{mean}] Output storage of the mean. If it is a null pointer,
    then it is ignored.
  \item[\texttt{cov}] Output storage of the covariance matrix. If it is a null
    pointer, then it is ignored.
  \item[\texttt{cov\_layout}] The storage layout of the covariance matrix.
  \item[\texttt{cov\_upper}] If true, then the upper triangular of the
    covariance matrix is packed, otherwise the lower triangular is packed. It
    is ignored if |cov_pack| is false.
  \item[\texttt{cov\_packed}] If true, then the covariance matrix is
    packed.
\end{description}

The last three parameters specify the storage scheme of the covariance matrix.
See any reference of \blas or \lapack for explanation of the scheme. Below is
an example of the class in use,
\begin{Verbatim}
using T = StateMatrix<RowMajor, p, double>;
Sampler<T> sampler(n);
// Configure and iterate the sampler
double mean[p];
double cov[p * (p + 1) / 2];
Covariance eval;
auto x = sampler.particle().state().data();
auto w = sampler.particle().weight().data();
eval(RowMajor, n, p, x, w, mean, cov, RowMajor, false, true);
\end{Verbatim}
One can later compute the Cholesky decomposition using \lapack or other linear
algebra libraries. Below is an example of using the covariance matrix to
generate multivariate Normal proposals,
\begin{Verbatim}
double chol[p * (p + 1) / 2];
double y[p];
LAPACKE_dpptrf(LAPACK_ROW_MAJOR, 'L', p, chol);
NormalMVDistribution<double, p> normal_mv(mean, chol);
normal_mv(rng, y);
\end{Verbatim}

\section{Store objects in \texorpdfstring{\protect\hdf5}{HDF5} format}
\label{sec:Store objects in HDF5 format}

If the \hdf library is available (|MCKL_HAS_HDF5|), it is possible to store
|Sampler| objects, etc., in the \hdf format. For example,
\begin{Verbatim}
hdf5store(sampler, "pf.h5", "sampler", false);
\end{Verbatim}
creates an \hdf file named |pf.h5| with the sampler stored as a list in the
group |sampler|. If the last argument is |true|, the data is inserted to an
existing file. Otherwise a new file is created. In R it can be processed as the
following,
\begin{Verbatim}
library(rhdf5)
pf <- as.data.frame(h5read("pf.h5", "sampler"))
\end{Verbatim}
This creates a |data.frame| similar to that shown in
section~\ref{sub:Implementation (PF)}. The |hdf5store| function is overloaded
for |StateMatrix|, |Sampler| and |Monitor|. It is also overloaded for
|Particle| if an overload for |T| is defined. They all follow the format as
above. In addition, the following creates a new empty \hdf file,
\begin{Verbatim}
hdf5store(filename);
\end{Verbatim}
and the following creates a new group named |dataname|,
\begin{Verbatim}
hdf5store(filename, dataname, append);
\end{Verbatim}

\section{Stop watch}
\label{sec:Stop watch}

Performance can only be improved after it is first properly profiled. There are
advanced profiling programs for this purpose. However, sometime simple timing
facilities are enough. The library provides a simple class |StopWatch| for this
purpose. As its name suggests, it works much like a physical stop watch. Here
is a simple example
\begin{Verbatim}
StopWatch watch;
for (int i = 0; i != n; ++i) {
    watch.start(); // Some computation
    // Computation to be benchmarked;
    watch.stop();  // Some other computation
}
double t = watch.seconds(); // The time in seconds
\end{Verbatim}
The above example demonstrate that timing can be accumulated between loop
iterations, function calls, etc. It shall be noted that, the timing is only
using if the computation between |start| and |stop| is non-trivial.
